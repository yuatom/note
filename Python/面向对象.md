# 面向对象

##类和实例
###定义类

```python
def Student(object):    # 括号内为继承的类，object为所有类的父类

    gender = 1  # 类属性，可以被类调用也可以被对象调用
    
    # 方法，第一个参数必须是self，但在调用时不必传入
    # __init__方法相当于构造方法
    def __init__(self, name, score): 
        self.name = name    # 对象属性定义，并赋值
        self.score = score
    
    # 方法，第一个参数必须是self
    def print_score(self):
        print('%s: %s' % (self.name, self.score))   # 类里面调用属性
```

###使用
```python
>>> bart = Student('Bart Simpson', 59)  # 实例化
>>> bart.name                           # 调用对象属性
'Bart Simpson'
>>> bart.score
59
>>> bart.print_score()                  # 调用对象方法
Bart Simpson: 59
```
Python中允许对象在类定义外动态的定义对象的属性：

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.age = 8    # 动态添加一个age属性
>>> bart.age
8
```

##访问限制
>* 公共属性：以字母开头的命名，在外部代码可以修改和访问；
>* 私有属性：属性名称加两个下划线`__`；

```python
class Student(object):
    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
```

调用私有属性
```python
>>> bart = Student('Bart Simpson', 98)
>>> bart.__name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute '__name'
```
####私有属性的实现
不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：

```python
>>> bart._Student__name
'Bart Simpson'
```

##获取对象信息
>* type(obj)，获取对象类型
>* isinstance(obj, ClassName)，判断对象对象的类或父类
>* dir(obj)，获取对象的所有属性和方法
>* hasattr(obj, attr)，是否拥有某个属性
>* getattr(obj, attr, defaultValue)，获取对象某个属性的值

##属性/方法动态添加及限制（__slots__）

```python
# 定义一个空类
class Student(object):
    pass
```

对象属性的动态添加，在类外部通过对象直接对属性赋值即可：

```python
>>> s = Studeng();
>>> s.name = 'Tony' #动态添加属性
>>> print(s.name)   
Michael
```

对于方法的添加，需要用到MethodType函数

```python
>>> def set_age(self, age): # 定义一个函数作为实例方法
...     self.age = age
...
>>> from types import MethodType    # 引入包
>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
>>> s.set_age(25) # 调用实例方法
>>> s.age # 测试结果
25

# 给类添加方法，添加后所有实例化出来的对象都拥有该方法
>>> def set_score(self, score):
...     self.score = score
...
>>> Student.set_score = MethodType(set_score, Student)
```
###使用__slots__限制属性
在类定义中添加类属性`__slots__`，将允许的属性名以tuple赋值给该属性。

```python
class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
    
>>> s = Student() # 创建新的实例
>>> s.name = 'Michael' # 绑定属性'name'
>>> s.age = 25 # 绑定属性'age'
>>> s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute 'score'
```
> `__slots__`仅对当前类的对象起作用，对该类的子类不起作用。

```python
# 子类
>>> class GraduateStudent(Student):
...     pass
...
>>> g = GraduateStudent()
>>> g.score = 9999
```


