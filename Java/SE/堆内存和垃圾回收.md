# 堆内存和垃圾回收
Java的堆(Heap)是存放对象的内存区域。在逻辑上我们可以把堆细分为新生代(Young Generation)、老年代(Old Generation)和永久代(Permanent Generation)。
##判断对象是否存活的方式
###1、引用计数法：Reference Counting
给每个对象添加引用计数器，当对象有新的引用时计数器+1，当对象某个引用失效时，计数器-1。当计数器为0时，该对象就可回收。
？这种方法很难解决对象的循环引用问题。

###2、根搜索算法：GC Roots Tracing（Java采用这个方式
即跟踪收集，从一组对象开始，沿着对象图上的关系递归确定可到达（reachable）的对象。如果某对象不能从这些根对象到达，则将它标记为垃圾收集。

##堆内存
堆内存中的划分：新生代（young generation）、老年代（old generation）、永久代（permanent generation）
###新生代
存放着新分配的及较年轻的对象。
新生代中划分出三个区域，其中相对大点的区域的称为“伊甸园区(Eden)”，两个相对小点的区域称为”From 幸存区(survivor)”和”To 幸存区(survivor)”。
伊甸园是进行内存分配的地方，是一块连续的空闲内存区域。在上面进行内存分配速度非常快，因为不需要进行可用内存块的查找。两个存活区中始终有一个是空白的。

###老年代
存放着长寿的对象，新生代的对象经过几次垃圾回收之后仍然存活的将存放到老年代，并且大对象可以不经过新生代直接存放在老年代；
###永久代
存放着需要伴随着整个JVM声明周期的对象。

##Java垃圾回收机制
###1、分类
####1、按线程数分
可分为串行垃圾回收和并行垃圾回收。串行回收每次只使用一个线程进行垃圾回收；并行回收每次使用多个线程同时进行回收。
####2、按工作模式
可分为并发式和独占式垃圾回收。并发式垃圾回收器可以和应用程序线程交替工作；独占式垃圾回收器会停止应用程序中的其他所有线程。
####3、按碎片处理方式
可分为压缩式垃圾回收和非压缩式垃圾回收，压缩式垃圾回收器在回收完成后会对存活对象进行压缩整理，消除回收后的碎片。
####4、按工作的内存区间
可分为新生代垃圾回收器和老年代垃圾回收器。

###2、收集算法
####标记－清除收集器
这种收集器首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存。这种收集器一般使用单线程工作并停止其他操作。

####标记－压缩收集器
有时也叫标记－清除－压缩收集器，与标记－清除收集器有相同的标记阶段。在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈。这种收集器也停止其他操作。

####复制收集器
这种收集器将堆栈分为两个域，常称为半空间。每次仅使用一半的空间，jvm生成的新对象则放在另一半空间中。gc运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。

####增量收集器
增量收集器把堆栈分为多个域，每次仅从一个域收集垃圾。这会造成较小的应用程序中断。

####分代收集器
这种收集器把堆栈分为两个或多个域，用以存放不同寿命的对象。jvm生成的新对象一般放在其中的某个域中。过一段时间，继续存在的对象将获得使用期并转入更长寿命的域中。分代收集器对不同的域使用不同的算法以优化性能。

####并发收集器
并发收集器与应用程序同时运行。这些收集器在某点上（比如压缩时）一般都不得不停止其他操作以完成特定的任务，但是因为其他应用程序可进行其他的后台操作，所以中断其他处理的实际时间大大降低。

####并行收集器
使用某种传统的算法并使用多线程并行的执行它们的工作。在多cpu机器上使用多线程技术可以显著的提高java应用程序的可扩展性。

###3、垃圾处理器指标
吞吐量
垃圾回收器负载
暂停时间
垃圾回收频率
反应时间
堆分配

###收集器应用
####1、新生代串行收集器（复制算法：Copying
特点：串行、独占式。
过程：
在GC前To Survivor保持清空，对象保存在Eden和From Survivor中，GC运行时，**Eden中的幸存对象被复制到To Survivor**。From Survivor中的幸存对象如果年龄没达到阀值(tenuring threshold)，对象会**从From Survivor复制到To Survivor**；如果达到阀值对象被复制到老年代。
复制阶段完成后，**Eden和From Survivor中只保存死对象，可以视为清空**。如果在复制过程中To 幸存区被填满了，剩余的对象会被复制到老年代中。
最后 From 幸存区和 To幸存区会调换下名字，在下次GC时，To 幸存区会成为From 幸存区。
通过以上步骤可得出：其中一个幸存者空间必须保持是空的。如果两个幸存者空间都有数据，或者两个空间都是空的，那一定标志着你的系统出现了某种错误。

使用：在 HotSpot 虚拟机中，使用-XX：+UseSerialGC 参数可以指定使用新生代串行收集器和老年代串行收集器。当 JVM 在 Client 模式下运行时，它是默认的垃圾收集器。

####2、老年代串行收集器（标记-压缩算法
复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在年轻代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。
老年代串行收集器使用的是标记-压缩算法，通常会使用比新生代垃圾回收更长的时间，因此，在堆空间较大的应用程序中，一旦老年代串行收集器启动，应用程序很可能会因此停顿几秒甚至更长时间。

特点：串行、独占式

过程：
通过对象遍历标记出不可到达的对象，对这些对象进行清除，然后对存活对象进行压缩，消除回收后产生的内存碎片。

使用：
>* 老年代串行回收器可以和多种新生代回收器配合使用，同时它也可以作为 CMS 回收器的备用回收器。
>* -XX:+UseSerialGC: 新生代、老年代都使用串行回收器；
>* -XX:+UseParNewGC 参数设置，表示新生代使用并行收集器，老年代使用串行收集器；
>* -XX:+UseParallelGC 参数设置，表示新生代和老年代均使用并行回收收集器。

####3、并行收集器
特点：并行、独占式。
只是简单地将串行回收器多线程化回收策略、算法以及参数和串行回收器一样。在并发能力比较强的CPU上，产生的暂停时间要短于串行回收器；在单CPU或并发能力弱的系统中，由于多线程的压力，效果不一定比串行的好。

使用：
>* -XX:+UseParNewGC，该参数设置新生代使用并行收集器，老年代使用串行收集器；
>* -XX:+UseConcMarkSweepGC 可以要求新生代使用并行收集器，老年代使用 CMS；

####4、新生代并行回收 (Parallel Scavenge) 收集器
特点：多线程、独占式，关注系统吞吐量。
同样也是使用复制算法。
使用：
>* -XX:+UseParallelGC:新生代使用并行回收收集器，老年代使用串行收集器。
>* -XX:+UseParallelOldGC:新生代和老年代都是用并行回收收集器
>* -XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间
>* -XX:+GCTimeRatio：设置吞吐量大小，它的值是一个 0-100 之间的整数。

####5、老年代并行回收收集器
特点：多线程、独占式，注重系统吞吐量。
使用标记-压缩算法。
使用：
>* -XX:+UseParallelOldGC:在新生代和老生代都使用并行回收收集器
>* -XX:ParallelGCThreads:设置并行的线程数量

####6、CMS（Concurrent Mark Sweep）收集器
特点：多线程，并发收集
并行回收收集器关注系统吞吐量，而CMS收集器关注的是系统停顿时间。
CMS采用的标记清除算法，工作过程：
> 1、初始标记，为了收集应用程序的对象引用需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动（标记，独占系统资源；
> 2、并发标记，从第一阶段收集到的对象引用开始，遍历所有其他的对象引用（可和用户线程一起执行；
> 3、重新标记，由于上一步是并发的，因此该步骤是标记上一步中变化的对象（标记，独占系统资源；
> 4、并发清除，正式回收垃圾对象（可和用户线程一起执行；
> 5、并发重置，重新初始化CMS数据结构和数据，为下次回收做准备（可和用户线程一起执行。

使用：
>* -XX：+UseConcMarkSweepGC，启用CMS收集器，默认是使用并行；
>* -XX：UseParNewGC，新生代使用多线程并行，默认随UseConcMarkSweepGC开启；
>* -XX：+CMSConcurrentMTEnabled，开启多线程，默认是开启的；
>* -XX：ConcGCThreads，CMS并发的线程数；
>* -XX:CMSInitiatingOccupancyFraction，触发CMS收集的老年代使用率，当老年代中达到这个值时，CMS收集器会被触发；
>* -XX：+UseCMSInitiatingOccupancyOnly，只根据老年代使用率来触发CMS，不基于JVM运行收集的数据，大多数情况下JVM更懂得何时触发，除非测试情况下，不建议使用该选项；
>* -XX:+CMSClassUnloadingEnabled，对永久代也进行垃圾回收，CMS收集器默认是不对永久代进行回收；
>* -XX:+CMSIncrementalMode，开机CMS收集器的增量模式；
>* -XX:+ExplicitGCInvokesConcurrent，无论什么时候调用系统GC，都执行CMS GC，而不是Full GC；
>*  -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses，s保证当有系统GC调用时，永久代也被包括进CMS垃圾回收的范围内；
>* -XX:+DisableExplicitGC，完全忽略系统的GC调用(不管使用的收集器是什么类型)。

####7、G1 收集器 (Garbage First)
G1 收集器的目标是作为一款服务器的垃圾收集器，因此，它在吞吐量和停顿控制上，预期要优于 CMS 收集器。
与 CMS 收集器相比，G1 收集器是基于标记-压缩算法的。因此，它不会产生空间碎片，也没有必要在收集完成后，进行一次独占式的碎片整理工作。G1 收集器还可以进行非常精确的停顿控制。它可以让开发人员指定当停顿时长为 M 时，垃圾回收时间不超过 N。
G1将堆空间分成了互相独立的区块，每个区域有可能是eden、survivor、old中的一种，且每类空间可以是不连续的（对比CMS的O区和Y区各部分都必须是连续的）。

#####过程
>* YGC（不同于CMS）
>* 并发阶段（老年代

######YGC
当堆内存中的Eden区域被填满时，触发YoungGC，回收之后所有的Eden全变空白（不属于任何类型），存活的对象被移动到S（survivor）区域或O（Old）区。
PrintGCDetails参数可以打印出GC日志

```shell
23.430: [GC pause (young), 0.23094400 secs]
...
[Eden: 1286M(1286M)->0B(1212M)
Survivors: 78M->152M Heap: 1454M(4096M)->242M(4096M)]
[Times: user=0.85 sys=0.05, real=0.23 secs]
```
上面日志的内容解析：
>* Young GC实际占用230毫秒、其中GC线程占用850毫秒的CPU时间；
>* E：内存占用从1286MB变成0、都被移出；
>* S：从78M增长到了152M、说明从Eden移过来74M；
>* Heap:占用从1454变成242M、说明这次Young GC一共释放了1212M内存空间。
很多情况下，S区的对象会有部分晋升到Old区，另外如果S区已满、Eden存活的对象会直接晋升到Old区，这种情况下Old的空间就会涨。

######并发阶段
1、初始标记阶段(Initial Mark)
这个阶段会暂停所有应用线程，部分原因是这个过程会执行一次YGC，及标记可能有引用指向老年代对象的survivor区(根regions)；

```shell
日志示例：

50.541: [GC pause (young) (initial-mark), 0.27767100 secs]
[Eden: 1220M(1220M)->0B(1220M)
Survivors: 144M->144M Heap: 3242M(4096M)->2093M(4096M)]
[Times: user=1.02 sys=0.04, real=0.28 secs]
```
上面的日志表明发生了YGC、应用线程为此暂停了280毫秒，Eden区1220M空间被清空，Heap占用从3242M变成2093M，说明释放了1149M空间，71MB从Young区移到了O区。
2、扫描根区域(Root Region Scanning)
扫描 survivor 区中引用到老年代的引用. 这个阶段应用程序的线程会继续运行. 在年轻代GC可能发生之前此阶段必须完成。

```shell
50.819: [GC concurrent-root-region-scan-start]
51.408: [GC concurrent-root-region-scan-end, 0.5890230]
```
如果Young区空间恰好在Root扫描的时候满了、YGC必须等待root扫描之后才能进行。带来的影响是YGC暂停时间会相应的增加。

```shell
350.994: [GC pause (young)
351.093: [GC concurrent-root-region-scan-end, 0.6100090]
351.093: [GC concurrent-mark-start],0.37559600 secs]
```

3、并发标记(Concurrent Marking)
在整个堆中查找活着的对象，如果找到空的区域，这些区域会在Remark阶段立即清除。
此阶段应用程序的线程正在运行. 此阶段可以被年轻代GC打断(interrupted)；

4、再次标记(Remark)
(Stop the World Event，所有应用线程暂停) 完成堆内存中存活对象的标记. 使用一个叫做 snapshot-@-the-beginning(SATB, 起始快照)的算法, 该算法比CMS所使用的算法要快速的多。
清除并回收空的区域，然后计算区域的活跃度(Region liveness)。

5、拷贝(Copying)/清理(Cleanup)

(Stop the World Event,所有应用线程暂停) 产生Stop The World事件来**转移或拷贝存活的对象到新的未使用的heap区(new unused regions)**. 只在年轻代发生时日志会记录为 [GC pause (young)]. 如果在年轻代和老年代一起执行则会被日志记录为 [GC Pause (mixed)]

(Stop the World Event，所有应用线程暂停，并发执行)
在存活对象和完全空闲的区域上执行统计(accounting). (Stop the world)
擦写 Remembered Sets. (Stop the world)
重置空heap区并将他们返还给空闲列表(free list). (Concurrent, 并发)

#####特点：
>* 可以像CMS收集器一样,GC操作与应用的线程一起并发执行；
>* 紧凑的空闲内存区间且没有很长的GC停顿时间；
>* 需要可预测的GC暂停耗时；
>* 不想牺牲太多吞吐量性能；
>* 启动后不需要请求更大的Java堆

#####使用：
>* -XX:+UseG1GC：使用 G1 回收器。
>* -XX:+UnlockExperimentalVMOptions:允许使用实验性参数。
>* -XX:+MaxGCPauseMills:设置最大垃圾收集停顿时间。
>* -XX:+GCPauseIntervalMills:设置停顿间隔时间
>* -XX:MaxGCPauseMillis=n:设置最大GC停顿时间(GC pause time)指标(target)





