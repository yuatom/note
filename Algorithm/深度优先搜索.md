# 深度优先搜索

深度优先算法，每一次都沿着某个点一直往下查找，查找不到时再返回到，查找与这个点平级的点的下一步：

 * 查找A下的点，发现有B，查找B下一步能去的点，发现有C，查找C下一步能去的点，发现有D，查找D下一步能去的点，没有，返回到C
 * 查找C下面除了D的点，发现有F，查找F下面的，没有，返回到C
 * 查找C下面除了D和F的点，没有，返回到B
 * 查找B下面除了C的点，发现有E，查找E下面的点，没有，返回B
 * 查找B下面除了C和E的点，没有，返回A
 * 查找A下面除了B的点......

关键点

 * 需要一个变量来记录当前层已经去过的点，即上面的“查找x下面除了y,z的点”中的y,z，因为当前层的下一层也许不能和当前层的点重复
 * 每次进入下一层时判断前面那层是否已经去过
 * 如果与当前层平级的点的下一层可以用到当前的点，那当前点下面那些查找完后要把当前点从变量中去除

##应用
###1.数字全排列
输出1~n直接的所有数字排列
实现：

* 当第一位是1时，第二位可能是2或者3
* 第二位是2这个点的时候，记录2已经用过，进入到第三位，只能用3，即1 2 3，查找后返回去查找3的
* 第二位是3，如果2那个点递归完后没有把标记去除，那么第三位就不能再用2，即只是1 3
* 如果在2遍历完之后把标记去除，那么第三位还能再用2，即结果是1 3 2


###2.加法组合
计算1-9中，[xxx]+[xxx]=[xxx]

###3.在坐标中搜索某个点

###4.小岛面积
地图上的海拔高度，0表示海平面，1~9都表示陆地，数字的大小表示海拔的高低。
假设初始点在(6，4)处，现在需要计算出该点周围有多少个非0的格子，即该岛的面积。这里把初始点相邻的陆地是为一个岛。

###5.小岛个数
地图上的海拔高度，0表示海平面，1~9都表示陆地，数字的大小表示海拔的高低。
假设初始点在(6，4)处，查找地图有多少个独立的岛 。

###6.炸弹人
炸弹人，找出可以放置炸弹的能炸最多目标的
\#是墙
.是平地，可以放置炸弹
G是目标
$map = [
	['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
	['#', 'G', 'G', '.', 'G', 'G', 'G', '#', 'G', 'G', 'G', '.', '#'],
	['#', '#', '#', '.', '#', 'G', '#', 'G', '#', 'G', '#', 'G', '#'],
	['#', '.', '.', '.', '.', '.', '.', '.', '#', '.', '.', 'G', '#'],
	['#', 'G', '#', '.', '#', '#', '#', '.', '#', 'G', '#', 'G', '#'],
	['#', 'G', 'G', '.', 'G', 'G', 'G', '.', '#', '.', 'G', 'G', '#'],
	['#', 'G', '#', '.', '#', 'G', '#', '.', '#', '.', '#', '.', '#'],
	['#', '#', 'G', '.', '.', '.', 'G', '.', '.', '.', '.', '.', '#'],
	['#', 'G', '#', '.', '#', 'G', '#', '#', '#', '.', '#', 'G', '#'],
	['#', '.', '.', '.', 'G', '#', 'G', 'G', 'G', '.', 'G', 'G', '#'],
	['#', 'G', '#', '.', '#', 'G', '#', 'G', '#', '.', '#', 'G', '#'],
	['#', 'G', 'G', '.', 'G', 'G', 'G', '#', 'G', '.', 'G', 'G', '#'],
	['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
];

