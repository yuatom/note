# 广度优先搜索
查找某个点的下一步所有可能的点，然后在查找这些点的下一步的可能的点。每次只查一层，查询完之后退回上一层，上一层查完了，就拿当前层的点来往下查。

 * 	已知点A，查询A下一步可能是B和C，查找完毕返回A那一层，发现没有可查，进入BC那一层；
 * 	查找B下一步的点，可能是D和E，查找完毕返回BC那一层，往下查找C下一步；
 * 	查找C下一步的店，可能是D和F，查找完毕返回BC那一层，发现没有可查，进入DEF那一层；
 * 	如此类推，像上面D有重复，可以用一个变量来存储查找过的点


关键点

 * 可以使用队列来记录查找到的点，队列头表示当前查找的点，查找到点添加到队列尾
 * 第一次查找的点会在队列头，这个点的下一级会在这个队列头之后，这个点的下一级的下一级，会这个点的下一级之后
 * 用数字来表示层数，队列中节点的层数可能是：1 2 2 2 3 3 3 4 4 4 4 ...
 * 即沿着队列头往下，就能遍历当前层的所有下一步可能，并添加到后面
 * 每次查询完当前点的子节点，队列head移到下一位，即出队列

##应用
###1.数字全排列
输出1~n直接的所有数字排列
实现：

* 当第一位是1时，第二位可能是2或者3
* 第二位是2这个点的时候，记录2已经用过，进入到第三位，只能用3，即1 2 3，查找后返回去查找3的
* 第二位是3，如果2那个点递归完后没有把标记去除，那么第三位就不能再用2，即只是1 3
* 如果在2遍历完之后把标记去除，那么第三位还能再用2，即结果是1 3 2


###2.加法组合
计算1-9中，[xxx]+[xxx]=[xxx]

###3.在坐标中搜索某个点

###4.小岛面积
地图上的海拔高度，0表示海平面，1~9都表示陆地，数字的大小表示海拔的高低。
假设初始点在(6，4)处，现在需要计算出该点周围有多少个非0的格子，即该岛的面积。这里把初始点相邻的陆地是为一个岛。

###5.小岛个数
地图上的海拔高度，0表示海平面，1~9都表示陆地，数字的大小表示海拔的高低。
假设初始点在(6，4)处，查找地图有多少个独立的岛 。

###6.炸弹人
炸弹人，找出可以放置炸弹的能炸最多目标的
\#是墙
.是平地，可以放置炸弹
G是目标
$map = [
	['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
	['#', 'G', 'G', '.', 'G', 'G', 'G', '#', 'G', 'G', 'G', '.', '#'],
	['#', '#', '#', '.', '#', 'G', '#', 'G', '#', 'G', '#', 'G', '#'],
	['#', '.', '.', '.', '.', '.', '.', '.', '#', '.', '.', 'G', '#'],
	['#', 'G', '#', '.', '#', '#', '#', '.', '#', 'G', '#', 'G', '#'],
	['#', 'G', 'G', '.', 'G', 'G', 'G', '.', '#', '.', 'G', 'G', '#'],
	['#', 'G', '#', '.', '#', 'G', '#', '.', '#', '.', '#', '.', '#'],
	['#', '#', 'G', '.', '.', '.', 'G', '.', '.', '.', '.', '.', '#'],
	['#', 'G', '#', '.', '#', 'G', '#', '#', '#', '.', '#', 'G', '#'],
	['#', '.', '.', '.', 'G', '#', 'G', 'G', 'G', '.', 'G', 'G', '#'],
	['#', 'G', '#', '.', '#', 'G', '#', 'G', '#', '.', '#', 'G', '#'],
	['#', 'G', 'G', '.', 'G', 'G', 'G', '#', 'G', '.', 'G', 'G', '#'],
	['#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'],
];


