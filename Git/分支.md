# 分支

﻿http://blog.jobbole.com/25877/
##原理
git保存了一个HEAD指针，指向正在工作中的本地分支的指针，可想象为是当前分支的别名。 
##分支管理
$ git branch branch_test        创建分支  $ git checkout branch_test    切换分支      $ git checkout -b branch_test    创建并切换分支  $ git merge hotfix    合并分支    将目标分支合并到当前分支中，即移动当前分支指针，删除目标分支指针  -d    删除分支 
##查看
$ git branch    不加参数时为列出所有分支，前面带*符号为当前坐在分支 
-v    查看各分支最后一次提交的对象 --merged    已合并的分支 --no-merged        查看尚未合并  vim index.php git add index.php git commit index.php -m 'add index.php' git branch   git branch -v  git chechout master 这条命令做了两件事。它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 branch_testi 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。分支示意图:  vim index.php git add index.php git commit -a -m 'add index.php in master branch' 切换回master分支后将index.php提交到该分支，分支示意图：
  git branch -v

##合并
git checkout -b branch_merge vim branch_merge.php git add branch_merge.php git commit -m 'add branch merge testing file branch_merge.php' git branch -v   分支示意图：hotfix为上文的branch_merge  git checkout master        //切换到master git merge branch_merge    //合并分支   此时出现Fast-forward提示，即快进。由于master分支处于branch_merge分支的上游，因此合并时git只需要把分支指针右移。这种单线的历史分支再合并时不存在需要解决的冲突，这样的过程即快进。 此时分支示意图：   此时可用删除与master指向相同的分支： git branch -d branch_merge   git checkout branch_test //切换到该分支重新操作 vim index.php // 修改改文件 git commit -a -m 'modify index.php on branch_test' //跳过添加到暂存区直接提交已追踪的文件 此时分支情况示意图：   git checkout master    //切换回主分支 git merge branch_test    //将刚刚的分支合并到主分支上 如果此时将branch_test合并到master上，情况和刚才合并不同。 “因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。” 
##冲突合并
$ git merge iss53 Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result.            //报冲突 
###查看冲突状态
[master*]$ git status index.html: needs merge # On branch master # Changed but not updated: # (use "git add ..." to update what will be committed) # (use "git checkout -- ..." to discard changes in working directory) # # unmerged: index.php                        //冲突的文件 #
  任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git 会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：  可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容，下半部分是在branch_test分支中的内容。 手动处理后将文件添加到暂存区，标记为已解决 git add index.php    // 添加到暂存区，标记为已解决 git commit     //完成提交合并 enter后显示编辑提交记录    可视化合并工具 默认为mergetool，Mac下没有该工具因此自动选择了opendiff  


##利用分支开发
长期分支 特性分支

###远程分支
通过克隆将远程的数据下载到本地，建立一个指向master的指针
####远程分支与本地分支
一次Git克隆会建立你自己的本地分支 master 和远程分支 origin/master，它们都指向 origin/master 分支的最后一次提交 在自己的库中操作的是master，无法操作origin/master，操作本地master后将改动push到远程，则会推动服务器的分支指针  如果你在本地 master 分支做了些改动，与此同时，其他人向远程推送了他们的更新，那么服务器上的master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动 
###同步远程分支
git fetch 远程名 分支名 值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针。  $ git checkout -b serverfix origin/serverfix 以上命令执行，会在本地产生一个serverfix分支，创建时该分支指针指向本地中的origin/serverfix 分支
 ###查看远程分支 git branch -a 

###将本地分支推送到远程分支
git push [remote-name] [branch-name]    将本地git库的数据更新到远程库中
git push origin master        将本地origin下master分支中的数组更新到远程库中的master分支中
= git push origin master:master，即将本地的master分支推送到远程库的master
git push origin localBranch:remoteBranch
--force     覆盖了服务器上的历史


###跟踪远程分支
从远程分支 checkout 出来的本地分支，称为 跟踪分支 (tracking branch)。跟踪分支是一种和某个远程分支有直接联系的本地分支。在跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。
<font color='red'>git checkout --track 远程库命/远程分支名</font>        将当前分支追踪到远程的分支上。
在克隆仓库时（git clone url）,Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是 git push 和 git pull 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如 origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：git checkout -b [分支名] [远程名]/[分支名]

###删除远程分支
git push origin --delere <branchName>

 
##分支的衍合
git rebase branchName        将制定的分支分衍合到当前的分支
git rebase branchName1 branchName2        将分支2衍合到分支1
git rebase branchName1 branchName2 branchName3    将分支3，从与分支2的父节点之后的变化，衍合到分支1

把一个分支中的修改整合到另一个分支的办法有两种：merge 和 rebase（rebase 的翻译暂定为“衍合”）
merge是将两个分支的节点对象合并产生一个新的对象，其实是三方合并，除了当前要合并的两个节点，git还会查询到这个两个节点的共同父节点，再进行合并：

git chekout master    //切换分支
git merge experiment    //merge


rebase：将C3里产生的变化补丁在C4的基础上重新打一遍。
git checkout experiment    //切换分支
git rebase experiment    //rebase

将C3的变化在C4中更新一次，在C4的基础上产生新的节点且experiment分支指针移动到该节点，此时切换到master分支，再进行快进合并。 git checkout master git merge experiment 
此时产生的C3'和普通三方合并产生的C5相比，快照内容基本是一样的。但衍合能产生一个更整洁的提交历史。

rebase基底分支
以下分支结构中，client有两个基底，一个是C2（基于master分支改变而来），一个是C3（基于server分支变化而来），当想把客户端的改变跳过sever（即C8C9部分）合并到master上，通过--onto选项指定基底。

git rebase --onto master server clinet 
"取出 client 分支，找出 client 分支和 server 分支的共同祖先（C3）之后的变化，然后把它们在 master 上重演一遍”。



####衍合注意事项 一旦分支中的提交对象发布到公共仓库后，就不要对该分支进行衍合操作。 
"在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用 git rebase 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。"



