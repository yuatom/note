# 进程管理
##进程
进程是处于执行期的程序，还包含该程序打开的文件、挂起的信号、内核内部数据、处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程，以及用来存放全局变量的数据段。进程是处于执行期的程序以及相关的资源的总称。

进程描述符，类型为`task_struct`，完整描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程状态及其他信息。进程描述符保存在一个叫做task list的双向循环连表中。

进程标识，PID，老版本的Unix和Linux中最大值默认是32768，这个值即是系统中允许同时存在的进程的最大数目。可以通过修改`/proc/sys/kernel/pid_max`来提高上限。
###创建进程
大多数操作系统创建进程的机制是先在新的地址空间里创建进程，读入可执行文件，最后开始执行。
在Unix系统中进程的创建将上述步骤拆分为两个单独的函数去执行：`fork()`和`exec()`。
通过调用`fork()`创建进程，该系统调用通过复制一个现有进程来创建一个全新的进程。
`fork()`通过拷贝当前进程来创建一个子进程，。该调用将会从内核中返回两次，一次是返回到父进程，父进程会恢复执行后面的代码，另一次是返回到新创建的程序来开始执行后面的代码。
子进程创建后会调用`exec()`来创建新的地址空间，将新的程序载入到该空间。
在现代的Linux中，`fork()`通常是由`clone()`系统调用实现。
程序最终通过`exit()`调用退出程序，该函数会终结进程并将其中占用的资源释放掉。
父进程可以通过`wait4()`来查询子进程是否终结，其标准动作是挂起调用它的进程，直到其中一个子进程退出，此时函数返回子进程PID。

####写时拷贝
传统的`fork()`会直接把所有的资源复制给新创建的进程，这种方式拷贝的数据无法共享。当新进程执行一个新的镜像时，之前的拷贝操作都将前功尽弃。
写时拷贝页的`fork()`在创建进程时并不复制整个进程的地址空间，而是父子进程共享一份拷贝，在进程（父/子）需要写入的时候，数据才会被复制到自己的拷贝。在复制之前，只是以只读的方式共享数据。
> fork的实际开销是复制父进程的页表以及给子进程创建唯一的进程描述符。一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就会被使用的数据。

`fork()`、`vfork()`及`__clone()`都是通过传递不同参数标志调用`clone()`实现，然后由`clone()`调用`do_fork()`。
 
`do_fork()`，该函数调用`copy_process()`之后运行新进程；
copy_process()：
>* 为新进程创建内核栈，`thread_info`结构和`task_struct`，这些值与当前进程的值相同；
>* 检查当前系统资源是否能够创建进程，进程数目是否超出用户限制；
>* 子进程将自己的进程描述符中部分成员设为初始值；
>* 子进程的状态设置为`TASK_UNINTERRUPTIBLE`，以保证它不会投入运行；
>* `copy_process()`调用`copy_flags()`来更新`task_struct`的flag成员；
>* 调用`alloc_pid()`为新进程分配一个有效的PID；
>* 根据`clone`的参数，`copy_process`拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。一般情况下，这些资源会被给定进程的所有线程共享，否则，这些资源是进程自身的一份拷贝；
>* 最后`copy_process`做扫尾工作并返回一个指向子进程的指针。
`copy_process`执行成功回到`do_fork()`，新进程将被唤醒并投入运行。内核有意让子进程先执行（但不是都能如此），因为子进程一般会马上调用`exec()`函数，可以避免写时拷贝的额外开销。如果父进程先执行，有可能会开始向地址空间写入。在fork()之后与exec()之间，父子进程用的是相同的地址空间。两者的虚拟空间不同，但其对应的物理空间是同一个。

`vfork()`调用是通过向`clone()`传递一个特殊的标志来进行，功能和`fork()`功能相同，但是不会拷贝父进程的页表项，**与父进程共享内存空间**。子进程会作为父进程的一个单独线程在它的地址空间上运行，父进程会被阻塞，直到子进程退出或执行`exec()`。`vfork()`保证子进程比父进程先执行。
vfork的过程：
>* 调用`copy_process()`，将`task_struct`的`vfork_done`置为NULL；
>* 执行`do_fork()`，如果有给定特别参数标志，`vfork_done`会指向一个特定的地址；
>* 进入子进程执行，父进程等待子进程通过`vfork_done`指针发送信号；
>* 调用`mm_release()`，将进程退出内存空间地址，并检查`vfork_done`是否为空，不为空时向父进程发送信号；
>* 回到`do_fork()`，唤醒父进程。


##线程
进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。
内核调度的对象是线程，而不是进程。
线程之间可以共享虚拟内存，但每个线程都拥有各自的虚拟处理器（虚拟处理成进程一种觉得之间在独享处理器的假象）。
在Windows或Solaris系统中，为线程提供了专门的机制，相对于进程，线程会耗比较少的资源。但在Linux中，线程只是一个特殊的进程，一个能与其他进程共享某些资源的进程，每个线程都拥有唯一隶属自己的task_struct，在Linux内核中，线程看起来就像一个普通的进程。比如有一个包含四个线程的进程，Windows之类专门支持线程的系统会有一个包含指向四个不同线程的指针的进程描述符，这个描述符负责描述地址空间、打开的文件等共享资源。线程本身再去描述它独占的资源。而在Linux中，则会创建四个进程并分配四个普通的task_struct，在建立的时候指定这四个线程共享某些资源。

###创建线程
线程的创建和进程类似，只是在调clone的时候需要传递一些参数标志来指明共享的资源：

```shell
clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)
```
以上代码产生的子进程将与父进程共享地址空间、文件系统资源、温江描述符号和信号处理程序，即子进程是父进程的线程。
>* 普通的fork(): clone(SIGCHLD, 0)
>* vfork()实现：clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)

clone的参数标志：

|标志|含义|
|:--|:--|
|CLONE_FILES|父子进程共享打开的文件|
|CLONE_FS|父子进程共享文件系统信息|
|CLONE_IDLETASK|将PID设置为0|
|CLONE_NEWNS|为子进程创建新的命名空间|
|CLONE_PARENT|指定子进程与父进程拥有同一个父进程|
|CLONE_PTRACE|继续调试子进程|
|CLONE_SETTID|将TID回写至用户空间|
|CLONE_SETTLS|为子进程创建新的TLS|
|CLONE_SIGHAND|父子进程共享信号处理函数及被阻断的信号|
|CLONE_SYSVSEM|父子进程共享System V SEM_UNDO语义|
|CLONE_THREAD|父子进程放入相同的进程组|
|CLONE_VFORK|调用vfork，所以父进程这边睡眠等待子进程将其唤醒|
|CLONE_UNTRACED|防止跟踪进程在子进程强制执行CLONE_PTRACE|
|CLONE_STOP|以TASK_STOPPED状态开始进程|
|CLONE_CHILD_CLEARTID|清除子进程TID|
|CLONE_CHILD_SETTID|设置子进程的TID|
|CLONE_PARENT_SETTED|设置父进程的TID|
|CLONE_VM|父子进程共享地址空间|

###内核线程
独立运行在内核空间的标准进程，只在内核空间运行，从不切换到用户空间。
内核线程和普通的进程间的区别在于内核进程没有独立的地址空间，指向地址空间的mm指针被设置为NULL。
内核线程和普通进程一样，可以被调度，可以被抢占。

```shell
# 查看内核线程
ps -ef
```

##进程终结
当一个进程终结时，内核必须释放它所占有的所有资源，并将这一事件通知其父进程。
进程的析构一般是自身引起的，通过显式或隐式调用`exit()`主动终结，或者进程接受到它既不能处理也不能忽略的信号或异常时被动终结。终结进程大部分都靠`do_exit()`来完成。
###do_exit()
>* 将`task_stuct`中的标志成员置为PF_EXITING；
>* 调用`del_time_sync()`删除内核定时器，确保没有定时器在排队，也没有定时器处理程序在运行；
>* 调用`acct_update_integral()`输出记账信息；
>* 调用`exit_mm()`函数释放进程占用的`mm_struct`，如果没有别的进程使用它们，则彻底释放这块内存；
>* 调用`sem_exit()`函数，该函数让处于等待IPC信号队列的进程离开该队列；
>* 调用`exit_files()`、`exit_fs()`分别递减文件描述符、文件系统数据的引用计数，如果某个引用计数为0，则彻底释放；
>* 把存放在`task_struct`的`exit_code`成员中的任务退出代码设置为由`exit()`提供的退出代码（退出代码将存放在这里供父进程随时检索），或者去完成由内核机制规定的退出动作；
>* 调用`exit_notify()`向父进程发送信号，给子进程重新找养父，养父为线程组中其他线程或者为init进程，并把进程状态设置成`EXIT_ZOMBIE`；
>* 调用`schedule()`切换到新的进程，因为处于`EXIT_ZOMBIE`的进程不会再被调度，所以这是进程所执行的最后一段代码。
>* do_exit()永不返回。

经过以上操作之后，与进程相关联的都被释放掉（假设该进程是这些资源的唯一使用者）。此时进程不能再运行并且处于EXIT_ZOMBIE退出状态。它所有占有的内存仅有内核栈、thread_info结构和task_struct结构。这些信息存在的唯一目的就是给父进程提供信息。当父进程检索到这些信息后，或者通知内核这些是无关信息后，该进程占有的剩余内存都会被释放归还给系统使用。

###删除进程描述符
do_exit()之后进程以不能再运行，但是系统仍然保留它的进程描述以供在进程终结后仍能获得它的信息。do_exit()只完成了进程终结时的清理工作，但是并没有完成进程描述符的删除操作。
当要删除进程描述符时，调用`release_task()`来完成：
>* 调用`_exit_signal()`，该函数调用`_unhash_process()`，后者调用`detach_pid()`从pidhash上删除进程，同时也要任务列表中删除该进程；
>* `_exit_signal()`释放当前终结进程所使用的所有剩余资源，并进行最终统计和记录；
>* 如果这个进程是县城组最后一个进程，并且领头进程已经死掉，那么`release_task()`就要通知领头进程的父进程；
>* 调用`put_task_struct()`释放进程内核栈和thread_info结构所占的页，并释放`task_strcut`所占的slab的高速缓存。

至此进程描述符和所有进程独享的资源就全部被释放掉。

###为孤儿进程寻找父进程
如果一个父进程在子进程之前推出，如果没有机制来保证子进程能找到一个新的父进程，这些孤儿进程就会在退出时永远处于僵死状态，白白地耗费内存。所以将在子进程当前线程组内找一个线程作为父亲，或者让init进程作为它们的父进程。在`do_exit()`调用`exit_notify()`时，`exit_notify()`会调用`forget_original_parant()`，接着在`forget_original_parant()`调用`find_new_reaper()`来执行寻找父过程。

