# 内核数据结构
##1.链表
###1.1.单向链表&双向链表&环形链表

```c
// 单向链表，只能往一个方向移动
struct list_element {
    void *data;                 // 有效数据
    struct list_element $next;  // 指向下一个元素的指针
}

// 双向链表，可以往两个方向移动
struct list_element {
    void *data;                 // 有效数据
    struct list_element $next;  // 指向下一个元素的指针
    struct list_element $prev;  // 指向上一个指针
}
```

通常情况下，链表的最后一个元素之后就没有元素，因此最后一个元素的下一个元素指针值为NULL。但有的链表中，最后一个元素的下一个元素指针指向表头，称为环形指针。环形指针也有单向和双向。
Linux内核的标准链表就是采用环形双向链表。

###1.2.链表移动
单向链表只能向后移动，遍历时`需要线性地`访问第一个元素到最后一个元素之间的所有元素；
双向链表能够沿着两个方向移动，实现正反向的遍历。
使用链表存放数据的理想情况是需要遍历所有数据，或者需要动态增删数据。`如果需要随机访问数据，一般不适用链表。`
有时链表的首个元素会用一个特殊指针表示，该指针称为头指针，利用头指针可方便、快速地找到链表的起始端。

###1.3.Linux内核中的实现
####1.3.1.数据结构
大多数的链表实现方式：

```c
// 数据结构
struct fox {
    unsigned long tail_length;      // 尾巴长度
    unsigned long weight;           // 重量
}

// 在数据结构中嵌入链表指针，也可以理解为将数据结构塞入链表(直接拥有链表指针的结构)
struct fox {
    unsigned long tail_length;      // 尾巴长度
    unsigned long weight;           // 重量   
    struct fox *next;               // 下一个对象
    struct fox *prev;               // 上一个对象
}
```
Linux实现链表的形式，不是将数据数据塞入到链表中，而是在链表节点塞入数据结构。

```c
// 定义一个链表指针结构
struct list_head {
    struct list_head *next;
    struct list_head *prev;
}

// 将指针结构嵌入到数据中
struct fox {
    unsigned long tail_length;
    unsigned long weight;
    struct list_head list;
}

```
其中，fox的list.next指向下一个元素，list.prev指向上一个元素。
为了方便，内核提供了一组链表的操作，比如list_add()方法可以添加一个新的节点到链表中，但是这些操作都吱接受list_head结构作为参数。因此还需要能从链表指针就找到父结构数据。
通过container_of()宏可以很方便地从链表指针找到父结构中的任何数据，因为**在C语言中，一个给定结构中变量偏移在编译时地址就被ABI固定下来了**。

####container_of()
```c
// 传入ptr指针，已知该指针是某个类型type的一个member，返回包含ptr指针的type数据
#define container_of(ptr, type, member) ({                  \
    const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
    (type *) ( (char *)__mptr - offsetof(type, member) );   \
})
```
1.`const typeof( ((type *)0)->member ) *__mptr = (ptr)`：定义一个与ptr类型相同的临时指针变量来保存ptr的值：
1.1.`(type *)0`：type类型的数据（运用了0地址）；
1.2.`((type *)0)->member )`：type的member成员；
1.3.`typeof( ((type *)0)->member ) *__mptr`：typeof，由一个变量名来获取其类型，用type的成员member的类型来定义`*__mptr`；
2.`(type *) ( (char *)__mptr - offsetof(type, member) )`：根据`*__mptr`的值和type这个类型中member的指针偏移量，来计算出ptr所属的type结构数据的首地址；
2.1.`offsetof(type, member)`：type结构体中member成员和结构体首地址的偏移量，这里是字节单位；
2.2.`(char *)__mptr`：将*__mptr指针转换为字节单位长度的；
2.3.`( (char *)__mptr - offsetof(type, member) )`：ptr的值减去type结构体中member成员的地址偏移，能得出包含ptr的type结构体的首地址；
2.4.`(type *) ( (char *)__mptr - offsetof(type, member) )`：最后，转换类型。


####list_entry()
使用container_of，可以定义list_entry方法来获取list_head的父类型结构体：

```c
#define list_entry(ptr, type, member)   \
    container_of(ptr, type, member)
```
利用list_entry方法，内核提供了创建、操作链表以及其他链表管理的方法，这些方法都不需要知道list_head所嵌入对象的数据结构。

####1.3.2.定义链表变量

将链表节点嵌入到数据结构中：

```c
struct fox {
    unsigned long tail_length;
    unsigned long weight;
    bool is_fantastic;
    struct list_head list;
} 
```
定义数据结构变量：

```c
// 动态创建
struct fox *red_fox;    // 定义结构体指针
red_fox = kmalloc(sizeof(*red_fox), GFP_KERNEL);    // 分配内存/地址，参数1分配的块的大小，参数2分配标志
red_fox->tail_length = 40;  //  对于首地址的偏移？
red_fox->weight = 6;
red_fox->is_fantastic = false;
INIT_LIST_HEAD(&red_fox->list);

// 静态创建
struct fox red_fox = {
    .tail_length = 40,
    .weight = 6,
    .list = INIT_LIST_HEAD(red_fox.list),
};
```

###1.4.链表操作
链表操作实现的文件:linux/list.h。
链表操作的函数时间复杂度都有O(1)。

####1.4.1.添加节点
在一个链表中添加一个节点，如该链表的链表头是head，由于链表是双向链表，因此head->prev为链表的末端。

`list_add(struct list_head *new, struct list_head *head)`：在节点head后添加new；
`list_add_tail(struct list_head *new, struct list_head *head)`：在节点head前添加new；

```c
// 创建一个新的struct fox，并添加到fox_list
list_add(&f->list, &fox_list);  // &，取fox_list的地址

// 在链表的head节点后添加一个new节点
list_add(struct list_head *new, struct list_head *head)
{
    __list_add(new, head, head->next);
}

// 在链表的head节点前添加一个new节点
list_add_tail(struct list_head *new, struct list_head *head)
{
    __list_add(new, head->prev, head);
}

#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
	WRITE_ONCE(prev->next, new);   // 一次性将new赋值给prev->next，因为CPU中有些情况变量的读写不是一次完成
}
#else
extern void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next);
#endif
```

####1.4.2.删除节点
删除一个节点，不需要传入该节点所在的链表
`list_del(struct list_head *entry)`：将一个节点从所在的链表中删除；
`list_del_init(struct list_head *entry)`：将一个节点从所在的链表中删除，并重新初始化

```c
// 将节点从原来的链表中删除
static inline void list_del(struct list_head *entry)
{
    __list_del(entry->prev, entry->next);
    entry->next = LIST_POISON1; // ???
    entry->prev = LIST_POISON2; // ???
}

// 将节点从原来的链表中删除，并将该节点初始化为一个新的链表
static inline void list_del_init(struct list_head *entry)
{
	__list_del_entry(entry);
	INIT_LIST_HEAD(entry);
}

static inline void __list_del_entry(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
}

static inline void __list_del(struct list_head *prev, struct list_head *next)
{
    next->prev = prev;
    WRITE_ONCE(prev->next, next);
}
```

####1.4.3.移动和合并链表节点

`list_move(struct list_head *list, struct list_head *head)`：将list从原来的链表中删除，然后添加另一个链表的head节点后面；
`list_move_tail(struct list_head *list, struct list_head *head)`：将list从原来的链表中删除，然后添加到另一个链表的head节点前面，如果head是链表头，则list将会添加到链表尾部；
`list_splice(struct list_head *list, struct list_head *head)`：将list链表添加到另一个链表的head节点之后；
`list_splice_init(struct list_head *list, struct list_head *head)`：将list链表添加到另一个链表的head节点之后，并重新初始化原来的链表；

```c
static inline void list_move(struct list_head *list, struct list_head *head)
{
    __list_del_entry(list);
    list_add(list, head);
}

static inline void list_splice(const struct list_head *list, struct list_head *head)
{
    if (!list_empty(list))  // 判断链表是否为空
        __list_splice(list, head, head->next);
}

static inline void list_splice_init(const struct list_head *list, struct list_head *head)
{
    if (!list_empty(list)) {
        __list_splice(list, head, head->next);
        INIT_LIST_HEAD(list);
    }     
}

// 在prev和next中间插入list
static inline void __list_splice(const struct list_head *list, struct list_head *prev, 
                struct list_head *next)
{
    struct list_head *first = list->next;
    struct list_head *last = list->prev;
    
    first->prev = prev;
    prev->next = first;
    
    last->next = next;
    next->prev = last;
}
```

###1.5.遍历链表
链表遍历的时间复杂度为O(n)。
`list_for_each(p, list)宏`：遍历list链表，p为list中的节点；
`list_for_each_entry(p, list, member)宏`：遍历list链表，p是一个链表节点所在的数据结构；
`list_for_each_entry_reverse(p, list, member)宏`：反向遍历；
`list_for_each_safe(pos, n, head)宏`：在遍历的时候能删除当前元素；
`list_for_each_entry_safe(pos, n, head, member)宏`：在遍历的时候能删除当前元素；
>标准的遍历方法不能删除当前元素，因为每一次取下一个元素都是基于当前的next；linux提供的safe系列方法，需要传入一个与pos相同的指针n，用来保存当前元素的next，这样就可以删除当前元素

```c
struct list_head *p;
struct fox *f;
list_for_each(p, &fox_list){    // fox_list为fox的链表(头)
    f = list_entry(p, struct fox, list);
}

list_for_each_entry(f, &fox_list, list){
    // f就是一个fox数据结构
}

// pos是一个链表节点
// head是一个链表（头）
#define list_for_each(pos, head) \
    for(pos = (head)->next; pos != head; pos = pos->next)

#define list_for_each_safe(pos, n, head) \
    for(pos = (head)->next, n = post->next; pos != head; pos = n, n = pos->next)

// pos是一个包含list_head的数据结构变量
// head是一个list_head链表头
// list_head在pos中的成员名
#define list_for_each_entry(pos, head, member)  \
    for (pos = list_first_entry(head, typeof(*pos), member);   \
        &pos->member != (head);     \
        pos = list_next_entry(pos, member))

#define list_for_each_entry_safe(pos, n, head, member)  \
    for (pos = list_first_entry(head, typeof(*pos), member), \
        n = list_next_entry(pos, member);   \
        &pos->member != (head);     \
        pos = n, n = list_next_entry(n, member))

// 获取ptr下一个节点所在的结构体数据
// ptr，一个list_head
// type，包含list_head的结构体
// member，list_head在type中的成员名
#define list_first_entry(ptr, type, member) \
	list_entry((ptr)->next, type, member)

// pos，一个包含list_head的结构体变量
// member，list_head在type中的成员名
#define list_next_entry(pos, member) \
	list_entry((pos)->member.next, typeof(*(pos)), member)
	
	
#define list_for_each_entry_reverse(pos, head, member)  \
    for (pos = list_last_entry(head, typeof(*pos), member);     \
        &pos->member != (head); 	   \
        pos = list_prev_entry(pos, member))
```

####例子，inotify，内核文件系统的更新通知机制

```c
static struct inotify_watch *inode_find_handle(struct indoe *inode, 
        struct inotify_handle *ih)
{
    struct inotify_watch *watch;
    
    list_for_each_entry(watch, &inode->inotify_watch, i_list){
        if (watch->ih == ih)
            return watch;
    }
}


void inotify_inode_is_dead(struct inode *inode)
{
    struct inotify_watch *watch, *next;
    
    mutex_lock(&inode->inotify_mutex);
    list_for_each_entry_safe(watch, next, &inode->inotify_watches, i_list) {
        struct inotify_handle *ih = watch->ih;
        mutex_lock(&ih->mutex);
        inotify_remove_watch_locked(ih, watch);
        mutex_unlock(&ih->mutex);
    }
    mutex_unlock(&inode->inotify_mutex);
}

```

##2.队列
###2.1.kfifo
Linux内核通用队列实现成为kfifo。
和其他大多数队列实现类似，kfifo提供了两个主要的操作，enqueue和dequeue。
kfifo维护了两个偏移量：入口偏移和出口偏移。
入口偏移是指下一次入队列的位置，出口偏移是指下一次出队列的位置。
出口偏移总是小于或等于入口偏移，当出口偏移等于入口偏移时，表示队列为空。

###2.2.创建队列

kfifo_alloc(struct kfifo *fifo, usigned int size, gfp_t gfp_mask)：动态创建队列，使用gfp_mask自动分配内存；
kfifo_init(struct kfifo *fifo, void *buffer, unsigned int size)：自己指定一个内存地址，分配size大小的内存；



```c
#define kfifo_alloc(fifo, size, gfp_mask) \
__kfifo_int_must_check_helper( \
({ \
	typeof((fifo) + 1) __tmp = (fifo); \
	struct __kfifo *__kfifo = &__tmp->kfifo; \
	__is_kfifo_ptr(__tmp) ? \
	__kfifo_alloc(__kfifo, size, sizeof(*__tmp->type), gfp_mask) : \
	-EINVAL; \
}) \
)

#define kfifo_init(fifo, buffer, size) \
({ \
	typeof((fifo) + 1) __tmp = (fifo); \
	struct __kfifo *__kfifo = &__tmp->kfifo; \
	__is_kfifo_ptr(__tmp) ? \
	__kfifo_init(__kfifo, buffer, size, sizeof(*__tmp->type)) : \
	-EINVAL; \
})
```

###2.3.入队列


###2.4.出队列

###2.5.队列长度

###2.6.重置和撤销队列

###2.7.例子

##3.映射


##4.二叉树

二叉搜索树：根的左分支节点值都小于根节点值；右分支节点值都大于根节点值；所有子树都是二叉搜索树；

平衡二叉搜索树：所有叶子节点的深度差不超过1的二叉搜索树。

红黑树：一种自平衡二叉搜索树。着色特点：
>* 所有的节点要么是红色，要么是黑色；
>* 叶子节点都是黑色；
>* 叶子节点不包括数据；
>* 所有非叶子节点都有两个子节点；
>* 如果一个节点是红色，则它的子节点都是黑色；
>* 在一个节点到其叶子节点的路径中，如果总是包含同样数目的黑色节点，则该路径相比其他路径是最短的。
上述着色条件保证了最深的叶子节点的深度不会大于最浅叶子节点深度的两倍。


##5.数据结构的选择
需要遍历，链表；
需要生产/消费，队列；
需要存储大量数据，并且检索迅速，红黑树；


