# 阻塞/非阻塞/同步/异步/IO模型

I/O的两个阶段：

* 1.等待数据准备好；
* 2.将数据从内核缓冲复制到用户进程缓冲区

##1.概念

###阻塞与非阻塞
**阻塞**：函数调用结果返回前，线程会被挂起，直到调用结果返回。
**非阻塞**：函数不会阻塞调用它的线程，会立刻返回。

阻塞和非阻塞是指当进程访问的数据如果尚未就绪,进程是否需要等待,简单说这相当于函数内部的实现区别,也就是未就绪时是直接返回还是等待就绪。

一般在一个文件描述符上执行IO操作都是阻塞的，即当从一个管道中读取数据时，如果管道中恰好没有数据，那么read()会阻塞；如果管道中没有足够的空间保存代写入的数据时，write()也会阻塞。
在打开文件时设定了O_NONBLOCK标志，会以非阻塞的方式打开文件。如果I/O系统调用不能立刻完成，则会返回错误而不是阻塞进程。非阻塞IO可以运用到管道，FIFO，套接字，终端，伪终端以及其他一些类型的设备上。

###同步与异步
**同步**：需要用户进程主动去将存放在内核缓冲区中的数据拷贝到用户进程中（或者是用户主动等待消息通知？）。即发出一个调用时，要等待该调用返回结果，然后拷贝数据。同步I/O引起进程阻塞，直至I/O操作完成；
**异步**：内核会自动将数据从内核缓冲区拷贝到用户缓冲区上然后再通知用户（或者是被动接收消息通知？）。即在发出调用之后，不等调用返回结果就继续往下操作。

同步和异步是指`访问数据`的机制,同步一般指主动请求并等待I/O操作完毕的方式,当数据就绪后在读写的时候必须阻塞(区别就绪与读写两个阶段,同步的读写必须阻塞),异步则指主动请求数据后便可以继续处理其它任务,随后等待I/O,操作完毕的通知,这可以使进程在数据读写时也不阻塞。(等待"通知")。

##2.Linux的五种I/O模型
* 阻塞I/O（blocking I/O）
* 非阻塞I/O（nonblocking I/O）
* I/O复用（I/O multiplexing）
* 信号驱动I/O（signal driven I/O (SIGIO)）
* 异步I/O（asynchronous I/O (the POSIX aio_functions)）

前面四种都是同步的，只有最后一种才是异步I/O

###2.1.阻塞I/O（blocking I/O）
应用程序调用一个IO函数，会导致该应用程序被阻塞，等待数据准备好。如果数据没有准备好，则会一直等待，直到数据准备好了，数据从内核空间拷贝到用户空间，IO函数返回成功。
默认的socket都是阻塞的。

####过程
调用recv()/recvfrom()函数时，数据准备和数据复制的过程。

||应用进程||内核|||
|----|----|----|:---:|----|----|
|进程阻塞于revfrom的调用|revfrom|系统调用->|无数据准备好|-|||
||||↓|}|等待数据|
||||数据准备好|-||
||||拷贝数据|-||
||||↓|}|将数据从内核拷贝到用户空间|
||处理数据|<-返回成功提示|拷贝数据|-||
当用户进程调用revfrom()时，内核需要准备数据。这个过程需要等待，即用户进程会被阻塞。当数据准备好了，**用户进程将数据从内核空间拷贝到用户空间中**，返回结果之后，进程才解除block状态。

####优缺点
能够及时返回数据，无延迟
对内核开发者来说比较省事

对用户来说处于等待就要付出性能的代价
###2.2.非阻塞I/O（nonblocking I/O）
同步非阻塞就是采用轮询的方式获取系统调用的结果，而不是将进程挂起之后一直等待调用结果。
用户进程调用一个IO函数，如果数据没有准备好，也会立即返回，但返回的是一个错误码，进程在返回之后，可以去做其他事，然后再发起revfrom调用来检查数据是否准备好。当内核数据准备好时，拷贝数据到进程空间的过程，仍然处于阻塞状态。

####过程
||应用进程||内核|||
|----|----|:--:|:--:|----|----|
|进程反复revfrom的调用|revfrom|系统调用->|无数据准备好|-|||
|||<-EWOULDBLOCK||}||
||revfrom|系统调用->|无数据准备好|}|||
|||<-EWOULDBLOCK||}|等待数据|
||revfrom|系统调用->|无数据准备好|}|||
|||<-EWOULDBLOCK||}||
||revfrom|系统调用->|数据准备好|-||
||||拷贝数据|-||
||||↓|}|将数据从内核拷贝到用户空间|
||处理数据|<-返回成功提示|拷贝数据|-||


###2.3.I/O复用（I/O multiplexing）
I/O复用是在一次调用中同时查询多个文件描述符是否可读可写，而不像非阻塞那种每个进程去轮询自己的调用。

####过程
||应用进程||内核|||
|----|----|:--:|:--:|----|----|
|进程受select阻塞|select|系统调用->|无数据准备好|-|||
|等到有套接字可读时|||↓|}|等待数据|
|||<-返回可读条件|数据准备好|-||
|拷贝期间应用进程也会受阻塞|revfrom|系统调用->|拷贝数据|-||
||||↓|}|将数据从内核拷贝到用户空间|
||处理数据|<-返回成功提示|拷贝数据|-||

####select
调用select()会一直阻塞，直到一个或多个文件描述符集合成为就绪态。

```c
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, 
        struct timeval *timeout)
```
接收一个整型和三个文件描述符的集合以及一个阻塞的时间上限。
整型和文件描述符的集合指定了要检查的文件描述符的集合。整型要比几个集合中包含的最大文件描述符还要大1。readfds用来检测输入是否就绪；writefds用来检测输出是否就绪；exceptfds用来检测异常情况是否发生。

相关的宏：

* FD_ZERO(fd_set *fdset)：将fdset所指向的集合初始化为空；
* FD_SET(int fd, fd_set *fdset)：将文件描述符fd添加到由fdset所指向的集合中；
* FD_CLR(int fd, fd_set *fdset)：将文件描述符fd从fdset指向的集合中删除；
* FD_ISSET(int fd, fd_set *fdset)：检查fdset中是否有fd准备就绪
select的三个文件描述符集合参数都需要经过FD_ZERO、FD_SET初始化。

返回值：

* -1：出错；
* 0：还要处于就绪态的文件描述符；
* 返回正整数表示一个或多个文件描述符已经到达就绪态；

使用：

* 初始化文件描述符集合；
* 调用select；
* 判断select返回的结果
* 使用FD_ISSET遍历判断文件描述符集合是否有准备就绪的，需要将集合中的元素一个个遍历；

####poll
poll()的执行和select()很相似，区别是在如何指定待检查的文件描述符。select中要指定三个集合，分别代表不同事件；而在poll中只需要提供一列文件描述以及我们关心的事件。

```c
int poll(struct pollfd fds[], nfds_t nfds, int timeout);

struct pollfd {
    int     fd;         // 文件描述符
    short   events;     // 待检查的事件掩码
    short   revents;    // poll返回时，该文件描述符实际发生的事件掩码
}
```
timeout参数用来决定poll()的阻塞行为：

* -1：一直阻塞直到有文件描述符达到就绪；
* 0：不阻塞，只执行一次检查；
* 大于0：最多的阻塞时间

返回值：

* -1：出错；
* 0：还要处于就绪态的文件描述符；
* 返回正整数表示一个或多个文件描述符已经到达就绪态，返回值表示数组fds中拥有非零revents字段的pollfd结构体数量。

pollfd结构事件掩码

|位掩码|events中的输入|返回到revents|描述|
|:--:|:--:|:--:|:--:|
|POLLIN|√|√|可读取非高优先级的数据|
|POLLRDNORM|√|√|等同于POLLIN|
|POLLRDBAND|√|√|可读取优先级数据（Linux中不适用）|
|POLLPRI|√|√|可读取高优先级数据|
|POLLRDHUP|√|√|对端套接字关闭|
|POLLOUT|√|√|普通数据可写|
|POLLWRNORM|√|√|等同与POLLOUT|
|POLLWRBAND|√|√|优先级数据可写入|
|POLLERR||√|有错误发送|
|POLLHUP||√|出现挂断|
|POLLNVAL||√|文件描述符未打开|
|POLLMSG|||Linux中不适用|


####不同文件的准备就绪
普通文件：普通文件对于select来说总是可读和可写；对于poll来说，则会在revent中返回POLLIN和POLLOUT。
套接字：

|条件或事件|select()|poll()|
|:--:|:--:|:--:|
|有输入|r|POLLIN|
|有输出|w|POLLOUT|
|在监听套接字上建立连接|r|POLLIN|；
|接收到带外数据（只限TCP)|x|POLLPRI|
|流套接字的对端关闭连接或|rw|POLLIN/POLLOUT|
|执行了shutdown(SHUT_WR)||POLLRDHUP|


####select和poll的不足

* 每次调用都必须检查所有被指定的文件描述符，当数量一多时，轮询会耗太多时间；
* 每次都要传递一个待检查的文件描述符的数据结构给内核，然后内核再修改这个结构返回给程序检查状态；
* 调用完成后，必须检查返回的数据结构中的每个元素；


###2.4.信号驱动I/O（signal driven I/O (SIGIO)）
在I/O复用中，进程是通过系统调用来检查文件描述符是否可以执行I/O操作。
而在信号驱动I/O中，当文件描述符可以执行I/O操作时，进程会请求内核为自己发送一个信号。之后进程就可以执行任何其他的任务知道I/O就绪位置，此时内核会发送信号给进程。
即在进程调用前，向内核注册一个信号处理函数，之后立刻返回。之后进程不会被阻塞。当内核的数据准备就绪时，内核调用进程的信号处理函数，之后进程再去内核拷贝数据。

###2.5.异步I/O（asynchronous I/O (the POSIX aio_functions)）


###2.6.epoll
####优点
* 检查大量的文件描述符时，性能比select和poll高很多
* 即支持水平触发也支持边缘触发，select和poll只支持水平触发，信号驱动只支持边缘触发；
* 可避免复杂的信号处理流程；
* 灵活性高。
####数据结构
epoll的核心数据结构成为**epoll实例**，它和一个打开的文件描述符相关联。这个文件描述符不是用来做I/O操作的，它是内核数据结构的句柄，这些内核数据结构实现了以下两个目的：

* 记录在进程中声明过的感兴趣的文件描述符列表——interest list
* 维护了处于I/O就绪状态的文件描述符列表——ready list，该列表是上面列表的子集。

####相关调用
* epoll_create()，创建一个epoll实例，返回代表该实例的文件描述符；
* epoll_ctl()，操作同epoll实例相关联的兴趣列表，通过该函数，可以实现对兴趣列表中文件描述符的增删改；
* epoll_wait()，返回与epoll实例相关联的就绪列表中的成员；

####epoll_create()

```c
int epoll_create(int size)
```
创建一个epoll实例，size指定希望epoll实例来检查的文件描述符个数。该参数只是设置一个初始大小，不代表上限。后续Linux版本中该参数被忽略不用。
该调用返回代表新创建的epoll实例的文件描述符。当该文件描述符不再需要时，应该通过close()来关闭。

####epoll_ctl()

```c
int epoll(int epfd, int op, int fd, struct epoll_event *ev);
```

* fd：要操作的文件描述符，可以是管道、FIFO、套接字、POSIX消息队列、inotify实例、终端、设备，甚至是另一个epoll实例的文件描述符，**但是不能是文件或目录的文件描述符（会出现EPERM错误）**；
* op：要对fd进行的操作，取值范围：EPOLL_CTL_ADD|EPOLL_CTL_MOD|EPOLL_CTL_DEL；
* ev：指向结构体epoll_event的指针，该结构体定义如下：

```c
struct epoll_event {
    uint32_t        events;     // 事件掩码
    epoll_data_t    data;       // 用户数据
}

typedef union epoll_data{
    void        *ptr;   // 指向用户定义的数据的指针
    int         fd;     // 文件描述符
    uint32_t    u32;    // 32位整型
    uint64_t    u64;    // 64位整型
}
```
参数ev为文件描述符fd所做的设置如下：
>* epoll_event.events指定了要检查fd上的什么事件；
>* epoll_event.data可以在fd转成就绪态时传回给调用进程的信息；

epoll_create和epoll_ctl例子：

```c
int epfd;
struct epoll_event ev;
epfd = epoll_create(5);

if(epfd == -1){
    // error
}

ev.data.fd = fd;
ev.events = EPOLLIN;
if(epoll_ctl(epfd, EPOLL_CTL_ADD, fd, ev) == -1){
    // error
}
```
####epoll_wait()
epoll_wait()用于返回epoll实例中处于就绪态的文件描述符信息。单个epoll_wait()调用能返回多个就绪态文件描述符的信息。

```c
int epoll_wait(int epfd, struct epoll_event *evlist, int maxevents, int timeout);
```

* evlist：该参数传进去用于写入处于就绪态的文件描述符的信息。该数组的空间由调用者申请，所包含的元素个数由maxevents指定。evlist数组中每个元素就是单个就绪态文件描述符的信息。元素中的events成员返回了该描述符上已经发生的事件掩码。data返回的是在epoll_ctl()注册时设定的ev中的data，该字段是获取和注册时的文件描述符相关信息的唯一途径。因此**在调用epoll_ctl()时，要么将ev.data.fd设置为文件描述符号，要么将ev.data.ptr设置成指向包含文件描述符号的结构体**，以便在获取就绪态的文件描述符时可以追溯到原来注册时的信息；
* timeout：epoll_wait()的阻塞行为，有以下取值：
>* -1：调用将一直阻塞，直到兴趣列表中的文件描述符上有时间产生，获知知道捕获到一个信号为止；
>* 0：执行**一次**非阻塞式的检查，看兴趣列表中的文件描述符上产生了哪个事件；
>* 大于0：调用阻塞最长的时间。

返回：

* 成功时返回evlist数组中的元素个数；
* 如果在timeout超时后没有任何文件描述符处于就绪态则返回0；
* 出错时返回-1，并在errno中设定错误码。

####epoll事件
epoll_event.evnets的掩码：

|位掩码|作为epoll_ctl()的输入|由epoll_wait()返回|描述|
|:--:|:--:|:--:|:--:|
|EPOLLIN|√|√|可读取非高优先级的数据|
|EPOLLPRI|√|√|可读取高优先级数据|
|EPOLLRDHUP|√|√|套接字对端关闭|
|EPOLLOUT|√|√|普通数据可写|
|EPOLLET|√||采用边缘触发时间通知|
|EPOLLONESHOT|√||在完成事件通知之后禁用检查|
|EPOLLERR||√|有错误发生|
|EPOLLHUB||√|出现挂断|

>* EPOLLONESHOT：默认情况下，epoll_ctl()的EPOLL_CTL_ADD操作将文件描述符添加到实例感兴趣的列表后，它会保持激活状态，即之后调用epoll_wait()时会在该文件描述符处于就绪态时通知进程，直到进程显示地通过epoll_ctl()的EPOLL_CTL_DEL将文件描述符从感兴趣列表中删去。如果希望在某个文件描述符上只得到一次通知，那么可以通过epoll_ctl()调用对该文件描述符设置为EPOLLONESHOT。当设定了该标志后，这个文件描述符通知过一次之后，这个描述符在兴趣列表中就被标记为非激活状态。

####边缘触发通知
epoll默认的通知机制和select/poll，采用水平触发通知。
epoll还支持边缘触发方式进行通知。该方式下能返回自成上一次调用epoll_wait()以来有新的事件的文件描述符。如果有多个I/O事件发生的话，epoll会将它们合并成一次单独的通知，通过epoll_wait()返回（在信号驱动中会产生多个信号）。

例子：

* 套接字上有输入到来；
* 调用一次epll_wait()，无论是水平触发还是边缘触发，在该次调用中都会返回套接字处于就绪态；
* 再次调用epoll_wait()：

>* 如果是水平触发，那么该次调用会返回套接字处于就绪态；
>* 如果是边缘触发，那么该次调用会被阻塞，因为自动上一次epoll_wait()后没有新的输入；

