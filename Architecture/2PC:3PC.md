# 2PC/3PC

##2PC/3PC
通过多次提交来完成分布式事务。
分布式事务，要操作多个数据库的事务。

###Two Phase Commitment Protocol
两阶段提交，分为准备阶段和提交阶段。
####1. 准备阶段（投票阶段）
	>* 协调者询问参与者是否可以执行提交操作（vote），并等待响应；
	>* 参与者响应是否同意提交，。
####2. 提交阶段（执行阶段）
1) 当协调者收到的响应都是“同意提交”：
	>* 协调者向参与者发出正式提交（commit），并等待响应；
	>* 参与者正式完成操作，释放此次事务中占用的资源；
	>* 参与者向协调者发出完成提交；
	>* 协调者接收参与者完成的消息，完成此次分布式事务。
2) 当协调者收到的响应中有一个“中止”信息：
	>* 协调者向所有参与者发送回滚（rollback）请求；
	>* 参与者回滚，释放资源；
	>* 参与者向协调者发送回滚完成；
	>* 协调者接收所有回滚完成，取消事务。

无论最后结果如何，该阶段都将结束当前事务。

####不足
>* 参与者节点都是事务阻塞型。当参与者占用公共资源时，其他第三方节点访问公共资源会被阻塞；
>* 参与者宕机。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败；
>* 协调者宕机。参与者会一直阻塞下去。需要额外的备机进行容错。
>* 数据不一致。当协调者给部分参与者发送commit之后发生故障，其他未收到commit的参与者无法该次事务提交；
>* 当协调者发送commit后宕机，唯一收到该条commit的参与者也宕机时，无法知道该次事务执行状态；

###Three Phase Commitment Protocol
三阶段提交，在两阶段提交的基础上引入超时机制，并在第一阶段和第二阶段之后插入一个准备阶段。保证在最后提交阶段之前各参与节点的状态是一致的。三个阶段分别是CanCommit、PreCommit、DoCommit，其中DoCommit与2PC中第二阶段一致。
####1. CanCommit阶段
	>* 事务询问，协调者向参与者发送CanCommit请求，询问是否可以执行事务提交操作，等待响应；
	>* 响应反馈，参与者响应是否可以执行提交；

####2. PreCommit阶段
1) 协调者接收到的响应都是可以提交：
	>* 发送预提交请求，向参与者发送PreCommit请求，并进入Prepared阶段；
	>* 事务预提交，参与者接收到PreCommit请求，执行事务操作，将undo和redo信息记录到事务日志；
	>* 响应反馈，参与者执行完事务操作，返回ACK响应等待最终指令。
2) 协调者接收的响应中有不同意提交或超时：
	>* 发送中断请求，协调者向参与者发送abort请求；
	>* 中断事务，参与者在接收到abort或超时后未收到PreCommit请求，执行事务中断。

####3. DoCommit阶段：
1) 协调者收到所有参与者的的ACK响应，执行提交：
	>* 发送提交请求，协调者接收到参与者的ACK响应，从PreCommit状态进入到提交状态，并向所有参与者发送DoCommit请求；
	>* 事务提交，参与者收到DoCommit请求，执行事务提交，完成后释放事务资源；
	>* 响应反馈，参与者完成事务提交后向协调者发送ACK响应；
	>* 完成事务，协调者接收到所有参与者的ACK响应，完成事务。
2) 协调没有收到所有参与者的ACK响应或超时，执行中断事务：
	>* 发送中断请求，协调者向所有参与者发送abort请求
	>* 事务回滚，参与者收到abort后，利用PreCommit中的undo信息来执行事务回滚，在回滚完成之后释放资源；
	>* 反馈结果，参与者回滚完成后向协调者发送ACK消息；
	>* 中断事务，协调者接收到参与者反馈的ACK消息，执行事务中断。

####2PC与3PC
相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。
超时机制的引入意味着将两阶段的第二阶段再度分开成两个阶段：不确定阶段与确定阶段。超时以前是不确定操作阶段，超时以后是确定操作阶段。因为在超时发生以前，系统处于不确定阶段，但是超时发生以后，系统则转入确定阶段。超时事件本身，则是系统进行状态转换的信号。但是因为真正引起超时的错只会在协调者与参与者同时出错（对于不出错但超时的情况，视为出错。即超时本身就是一种错---如果超时不“是”错，那么超时机制在这里就不可能工作---这其实就是超时机制的逻辑根本所在。超时是一种错，所以超时可以被用来表示错。如果用一种不是错的信号来表示错，那要区分真正的错就会很困难了）的情况下才会发生，在其它所有的情况下并不会发生，所以必须对这些情况进行相同的状态划分：准备好与提交状态。这些名词并不是很合乎它要表示的语义，但两个状态足够表达所有的情况才是最重要的事情。至于语义，则可以在人的大脑中得到正确的转化。

