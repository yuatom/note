# 模块架构
##结构体

```c
/* 
 * 指令结构体
 * Nginx在解析配置文件中的一个配置项时首先会遍历所有的模块，对于每一个模块而言，会遍历
 * commands数组，此外，在数组中检查到ngx_null_command时，会停止当前模块解析该配置
 * nginx_null_command的定义
 * define ngx_null_command {ngx_null_string, 0, NULL, 0, 0, NUll } 
 */
typedef struct ngx_command_s ngx_command_t;
struct ngx_command_s {
    // 配置项名称
    ngx_str_t       name;
    // 配置项类型，指定配置项可以出现的位置，如在server{}或location{}中
    ngx_uint_t      type;
    // 出现了name中指定的配置项后，会调用下面的方法来处理配置项的参数
    char            *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
    // 在配置文件中的偏移量
    ngx_uint_t      conf;
    // 与conf配合使用
    ngx_uint_t      offset;
    // 配置项读取后的处理方法，必须是ngx_conf_post_t结构的指针
    void            *post;
}

/* 模块结构体 */ 
typedef struct ngx_module_s ngx_module_t;
struct ngx_module_s {
    /* 在定义变量时，可以用NGX_MODULE_V1代替ctx_inde，index~verson这些成员 */
    #define NGX_MODULE_V1   0, 0, 0, 0, 0, 0, 1
    ngx_uint_t      ctx_index;      //所属分类标识  
    ngx_uint_t      index;          //模块计数器  
    //以下预留成员暂未使用  
    ngx_uint_t      spare0;  
    ngx_uint_t      spare1;  
    ngx_uint_t      spare2;  
    ngx_uint_t      spare3;  
    ngx_uint_t      version;        //模块版本  
    
    void            *ctx;           //模块上下文  
    ngx_command_t   *commands;      //模块支持的命令集  
    ngx_uint_t      type;           //模块的种类  
                                                                
    //回调函数  
    ngx_int_t       (*init_master)(ngx_log_t *log);     //主进程初始化时调用*/  
    ngx_int_t       (*init_module)(ngx_cycle_t *cycle); //模块初始化时调用  
    ngx_int_t       (*init_process)(ngx_cycle_t *cycle);//工作进程初始化时调用  
    ngx_int_t       (*init_thread)(ngx_cycle_t *cycle); //线程初始化时调用  
    void            (*exit_thread)(ngx_cycle_t *cycle); //线程退出时调用  
    void            (*exit_process)(ngx_cycle_t *cycle);//退出工作进程时调用  
    void            (*exit_master)(ngx_cycle_t *cycle); //退出主进程时调用
     
    //以下预留成员暂未使用  
    uintptr_t       spare_hook0;  
    uintptr_t       spare_hook1;  
    uintptr_t       spare_hook2;  
    uintptr_t       spare_hook3;  
    uintptr_t       spare_hook4;  
    uintptr_t       spare_hook5;  
    uintptr_t       spare_hook6;  
    uintptr_t       spare_hook7;  
}
```

##官方核心类型的具体模块

ngx_core_module
ngx_errlog_module
ngx_events_module
ngx_openssl_module
ngx_http_module
ngx_mail_module

```c
/* 核心模块接口结构体 */
typeof struct {
    // 核心模块名称
    ngx_str_t       name;
    // 解析配置项前，Nginx框架会调用create_conf方法
    void            *(*create_conf)(ngx_cycle_t *cycle);
    // 解析配置项完成后，Nginx框架会调用init_conf方法
    char            *(*init_conf)(ngx_cycle_t *cycle, void *conf);
} ngx_core_module_t;

// 事件模块的通用接口
typedef struct {
    ngx_str_t           *name;
    void                *(*create_conf)(ngx_cycle_t *cycle);
    char                *(*init_conf)(ngx_cycle_t *cycle, void *conf);
    
    //定义了IO模型(epoll, poll, select)的各种抽象接口
    ngx_event_actions_t     actions;    
} ngx_event_module_t;
```


ngx_module_t->ctx，一个指针，指向模块上下文，模块上下文可能是以下四个接口的实例：

* ngx_core_module_t     核心模块接口(类型)
* ngx_http_module_t     http模块接口(类型)
* ngx_event_module_t    事件模块的通用接口(类型)
* ngx_mail_conf_ctx_t   邮箱配置模块的接口(类型)
这些类型来定义模块的上下文。

定义一个模块的步骤：

* 使用`ngx_command_t`定义一个ngx_type_xxx_commands[]数组，type为core|http|event|mail之一，xxx为模块名称；
* 使用`ngx_type_module_t`定义一个模块上下文ngx_xxx_module_ctx；
* 使用`ngx_module_t`定义模块，并传入模块指令集和上下文；
* 定义一个模块的配置结构体，然后再定义一个构建该结构体的函数，注册到ngx_xxx_module_ctx中；



ngx_cycle_t，Nginx核心的框架代码中的一个结构体。很多Nginx的进程都会有一个ngx_cycle_t结构体的成员
ngx_cycle_t->listening，一个动态数组，每个元素都是ngx_listening_t成员
ngx_listening_t，每个ngx_listening_t结构体代表Nginx要监听的一个端口;
ngx_cycle_t->conf_ctx;

ngx_process_t，Nginx进程信息的结构体，master进程中的所有子进程相关的状态信息都保存在一个ngx_process_t类型的ngx_processes的数组的


