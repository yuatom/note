# 高级特性
##元表metatable
Lua中的元表类似与C++中的操作符重载。
使用Lua中的操作符时，其实是调用Lua变量的元表中的一个属性方法，例如调用+时，调用的是__add方法。
修改表的操作符行为，可以通过修改表的元表元素。

* setmetatable(table, metatable)：此方法用于为一个表设置元表。
* getmetatable(object)：此方法用于获取表的元表对象

###修改元表行为

```lua
local set1 = {10, 20, 30}   -- 集合
local set2 = {20, 40, 50}   -- 集合

-- 将用于重载__add的函数，注意第一个参数是self
local union = function (self, another)
    local set = {}
    local result = {}

    -- 利用数组来确保集合的互异性
    for i, j in pairs(self) do set[j] = true end
    for i, j in pairs(another) do set[j] = true end

    -- 加入结果集合
    for i, j in pairs(set) do table.insert(result, i) end
    return result
end
setmetatable(set1, {__add = union}) -- 重载 set1 表的 __add 元方法

local set3 = set1 + set2
for _, j in pairs(set3) do
    io.write(j.." ")               -->output：30 50 20 40 10
end
```

###__index元方法
访问表元素时调用

```lua
-- key1是显示定义的
-- 通过定义__index元方法来获取key2
mytable = setmetatable({key1 = "value1"}, 
    {__index = function(self, key)
        if key == "key2" then
            return "metatablevalue"
        end
    end    
})

-- __index可以是一个表
-- 使用{__index = {}}作为元表
-- 使用{[2] = "world"}表作为__index的值
t = setmetatable({[1] = "hello",
    {__index = {[2] = "world"}}
})

```

###__metatable元方法
使得对象的使用者无法修改和查看对象的元表

```lua
Object = setmetatable({}, {__metatable = "You cannot access here"})

print(getmetatable(Object)) --> You cannot access here
setmetatable(Object, {})    --> 引发编译器报错
```

##模拟面向对象
使用表和元表来模拟面向对象

```lua
--> obj.lua
local _M = {}
local mt = {__index = _M}

function _M.method1()
    print("This is method 1")
end

function _M.method2()
    print("This is method 2")
end

-- 返回一个表，元表中用_M来作为模型
function _M.new()
    return setmetatable({}, mt)
end

return _M

--> test.lua
local obj = require("obj")
local o = obj.new()

o.method1() --> This is method1
o.method2() --> This is method2
```


##虚变量

##module
###require
require一个模块/文件，相当于定义一个函数，模块/文件里的代码是该函数的函数体。

```lua
-- 两者等价
local mod = require('mod')

local mod = (function ()
  <contents of mod.lua>
end)()
```
require引入时会缓存模块的执行结果，即require一个模块两次，但模块里的代码只会执行一次。

```lua
-- Suppose mod2.lua contains "print('Hi!')".
local a = require('mod2')  -- Prints Hi!
local b = require('mod2')  -- Doesn't print; a=b.
```

###dofile
和require类似，但是不会缓存执行结果。

```lua
-- dofile is like require without caching:
dofile('mod2.lua')  --> Hi!
dofile('mod2.lua')  --> Hi! (runs it again)
```

###loadfile
加载文件，当不会立刻执行。相当于保存require中那个函数的引用。

```lua
-- loadfile loads a lua file but doesn't run it yet.
f = loadfile('mod2.lua')  -- Call f() to run it.

-- loadstring is loadfile for strings.
g = loadstring('print(343)')  -- Returns a function.
g()  -- Prints out 343; nothing printed before now.
```

##正则表达式

##FFI



