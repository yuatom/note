# 基础

##数据类型
* string，字符串类型
* function，函数类型
* boolean，布尔类型
* number，数字类型
* nil，表示无效值
函数type()用来查看值/变量的类型：

```lua
print(type("hello world")) -->output:string
print(type(print))         -->output:function
print(type(true))          -->output:boolean
print(type(360.0))         -->output:number
print(type(nil))           -->output:nil
```

###nil
表示无效值，一个变量在一次赋值之前的默认值是nil，将nil赋给一个全局变量就等同于删除它。
OpenResty的Lua的接口提供了ngx.null，用来表示不同于nil的空值。

###boolean
Lua中nil和false的值为假，其他所有值均为真。

###number
Lua中的number类型用双精度浮点数来实现。

###string
三种方法来表示：
1、使用配对的单引号，'hello'；
2、使用配对的双引号，"hello"；
3、使用长括号

Lua的字符串是不可改变的值。
Lua的字符串的实现中有一个内化过程，即两个完全一样的Lua字符串在Lua虚拟机中只会存储一份。意味着：

* 创建相同的Lua字符串不会引入新的动态内存分配；
* 内容相同的Lua字符串不会占用多分存储空间；
* 创建好的Lua字符串直接比较是通过对比引用地址，时间开销有O(1)。

###table
table实现了抽象的关联数组。

```lua
local corp = {
    web = "www.google.com",   --索引为字符串，key = "web",
                              --            value = "www.google.com"
    telephone = "12345678",   --索引为字符串
    staff = {"Jack", "Scott", "Gary"}, --索引为字符串，值也是一个表
    100876,              --相当于 [1] = 100876，此时索引为数字
                         --      key = 1, value = 100876
    100191,              --相当于 [2] = 100191，此时索引为数字
    [10] = 360,          --直接把数字索引给出
    ["city"] = "Beijing" --索引为字符串
}

print(corp.web)               -->output:www.google.com
print(corp["telephone"])      -->output:12345678
print(corp[2])                -->output:100191
print(corp["city"])           -->output:"Beijing"
print(corp.staff[1])          -->output:Jack
print(corp[10])               -->output:360
```

table的key只能是字面量，不可以是引用的。

```lua
local t = {[{}] = 7}
print(t.{}) -- 返回nil，因为这里的{}和定义的{}不是同一个
```

###function
Lua中的函数也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函数，还可以作为其他函数的返回值


##表达式
###逻辑运算
and/or/not

* a and b 如果 a 为 nil，则返回 a，否则返回 b;
* a or b 如果 a 为 nil，则返回 b，否则返回 a。
* a and b or c类似于 a ? b : c

> 注意：所有逻辑操作符将 false 和 nil 视作假，其他任何值视作真，对于 and 和 or，“短路求值”，对于not，永远只返回 true 或者 false。

```lua
local c = nil
local d = 0
local e = 100
print(c and d)  -->打印 nil
print(c and e)  -->打印 nil
print(d and e)  -->打印 100
print(c or d)   -->打印 0
print(c or e)   -->打印 100
print(not c)    -->打印 true
print(not d)    -->打印 false
```

###字符串连接
Lua中的字符连接用操作符..（两个点），其中一个是数字的话，会将该数字转换成字符串。
字符串连接只会创建一个新字符串，不会改变原操作数。
此外，也可以使用`string.format`函数连接字符串。

```lua
print("Hello " .. "World")    -->打印 Hello World
print(0 .. 1)                 -->打印 01

str1 = string.format("%s-%s","hello","world")
print(str1)              -->打印 hello-world

str2 = string.format("%d-%s-%.2f",123,"world",1.21)
print(str2)              -->打印 123-world-1.21
```

##流程控制
###if/else


```lua
-- 1
if ... then

end

-- 2
if ... then

else

end

-- 3
if ... then

elseif ... then 

end

-- example
score = 0
if score == 100 then
    print("Very good!Your score is 100")
elseif score >= 60 then
    print("Congratulations, you have passed it,your score greater or equal to 60")
else
    if score > 0 then
        print("Your score is better than 0")
    else
        print("My God, your score turned out to be 0")
    end --与上一示例代码不同的是，此处要添加一个end
end
```

###while

```lua
while ... do

end

-- example
x = 1
sum = 0
while x <= 5 do
    sum = sum + x
    x = x + 1
end
print(sum)  -->output 15
```

###repeat
类似与其他语言的do-while，但是在条件为真时才结束。

```lua
repeat
    -- body
until 表达式
```


###for
####数字形式

```lua
for var = begin, finish, step do
    -- body
end
```
1、var从begin开始，每次以step为步长递增；
2、begin、 finish、 step 三个表达式只会在循环开始时执行一次;
3、第三个表达式 step 是可选的， 默认为 1 ;
4、控制变量 var 的作用域仅在 for 循环内，需要在外面控制，则需将值赋给一个新的变量 ;

####泛型

```lua
for <var-list> in <exp-list> do
    <body>
end
```
var-list是变量名列表，exp-list是表达式，表达式列表通常只有一个。
执行过程：
>* 1、初始化，执行in后的表达式，表达式返回三个值：迭代函数，状态常量，控制变量；
>* 2、将状态常量和控制变量作为参数调用迭代函数；
>* 3、将迭代函数返回的值赋值给变量列表；
>* 4、如果迭代函数返回的第一个值如果为nil时循环结束，否知执行循环体；
>* 5、将表达式返回的状态变量和迭代函数返回的第一个值作为新的控制变量传入调用迭代函数；

```lua
-- 以下两个代码块等价
for v1, ..., vn in explist do
    block
end

do
    local _f, _s, _var = explist
    while true do 
        local var_1, ..., var_n  = _f(_s, _var)
        _var = var_1
        if _var == nil then
            break
        end
        block
    end
end
```

调用例子

```lua
-- 打印数组a的所有值
local a = {"a", "b", "c", "d"}
for i, v in ipairs(a) do
  print("index:", i, " value:", v)
end

-- 打印table t中所有的key
for k in pairs(t) do
    print(k)
end
```

* ipairs是Lua基础库中用来遍历table中数组部分的迭代器函数。key从1开始递增，该key没有值时退出，即如果table的key不是连续的数字或者是字符串时，无法完全遍历。
* pairs可以遍历table所有的key

```lua
local days = {
   "Monday", "Tuesday", "Wednesday", "Thursday",
   "Friday", "Saturday","Sunday"
}

local revDays = {}
for k, v in pairs(days) do
  revDays[v] = k
end

-- print value
for k,v in pairs(revDays) do
  print("k:", k, " v:", v)
end

-- output:
k:  Tuesday   v: 2
k:  Monday    v: 1
k:  Sunday    v: 7
k:  Thursday  v: 4
k:  Friday    v: 5
k:  Wednesday v: 3
k:  Saturday  v: 6
```


##函数
###定义
###参数
调用时的参数数量不一定要和定义时的数量一致。
当调用的参数多于定义的参数时，多出的参数会被无视。
当调用的参数少于定义的参数时，少了那些参数在函数内的值为nil。
如果参数是一个table，在调用时可以省略括号。

```lua
-- A one-table-param function call needs no parens:
function h(x) print(x.key1) end
h{key1 = 'Sonmi~451'}  -- Prints 'Sonmi~451'.
```

###返回值
lua的函数可以有多个返回值，接收多个返回值时，按返回值的顺序接收。
接收返回值的变量数量不一定要和函数返回值的数量相等。

```lua
function bar(a, b, c)
  print(a, b, c)
  return 4, 8, 15, 16, 23, 42
end

x, y = bar('zaphod')  --> prints "zaphod  nil nil"
-- Now x = 4, y = 8, values 15..42 are discarded.
```
如果只想取第二个返回值，第一个返回又不想用变量来接收，可以用`-`来占位。

