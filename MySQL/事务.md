# 事务
##隔离级别
###未提交读，READ UNCOMMITED
一个事务中的操作，即使没有提交，这些修改在其他事务中也是可见的，因此会导致脏读。

###已提交读，READ COMMITED
一个事务中的操作，只在自己的事务中可见。

###可重复读，REPEATABLE READ
MySQL默认
>* 所有的select在第一次一致读以后在事务中都会使用医院的数据状态快照（会导致幻读，即在该事务提交之前，有其他事务修改了select的数据）

###可串行化，SERIALIZABLE
强制所有的事务串行执行，避免了幻读问题。
该级别会在读取的每一行数据上都加上锁，因此可能导致大量的超时和争锁操作。
>* 所有的select语句中都是默认加了一个lock in share mode的锁

###整理
|隔离级别|脏读可能性|不可重复读可能性|幻读可能性|加锁读|
|----|----|----|----|----|
|READ UNCOMMITED|Y|Y|Y|N|
|READ COMMITED|N|Y|Y|N|
|REPEATABLE READ|N|N|Y|N|
|SERIALIZABLE|N|N|N|Y|

>* 脏读：可能读到未提交的数据。
>* 不可重复读性：两次执行同样的查询，可能会得到不一样的结果。
>* 幻读：某个事务读取某个范围的数据时，另一个事务又在该范围内插入了新的记录，当之前的事务再读取该范围时，读不到新插入的。

###设置隔离级别

```mysql
SET TRANSACTION ISOLATION　LEVEL READ UNCOMMITED;

# 设置当前回话的隔离级别
SET SESSION TRANSACTION ISOLATION　LEVEL READ UNCOMMITED;
```

##死锁

##事务日志

##MySQL中的事务
###自动提交

###在事务中混用存储引擎
MySQL事务是由存储引擎实现的，服务器层不管理事务。当在一个事务中混合使用了事务型和非事务型的表，在正常提交时没有什么问题，但是在回滚时，非事务型的表的变更无法撤销。

###隐式和显示锁定
隐式：
InnoDB采用两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁在同一时间释放。

显式:
InnoDB支持以下显示锁定
>* SELECT ... LOCK IN SHARE MODE
>* SELECT ... FOR UPDATE

此外，MySQL执行`LOCK TABLES`和`UNLOCK TABLES`，这是在服务器层实现的，和存储引擎无关。在InnoDB下，没必要显示使用`LOCK TABLES`和`UNLOCK TABLES`，会严重印象性能。
>除了事务中禁用了AUTOCOMMIT可以使用LOCK TABLES外，其他任何时候都不要显示地执行LOCK TABLES，不管什么存储引擎

