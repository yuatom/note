# 索引
在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。
MySQL中的索引是引擎来实现的。

索引优点：

* 索引大大减少了服务器需要扫描的数据量；
* 索引可以帮助服务器避免排序和临时表；
* 索引可以将随机I/O变为顺序I/O；

三星索引：

* 索引将相关的记录放到一起；
* 索引中的数据顺序和查找中的排序顺序一致；
* 索引中的列包含了查询中需要的全部列；

##1.B-/+Tree
B-Tree泛指B-/+Tree索引结构，表示自平衡的树。B+Tree是B-Tree的一个变种。MySQL中的B-Tree大多使用B+Tree实现。


###B-Tree的查找
类似二分搜索

```c
BTree_Search(node, key) {
    if(node == null) return null;
    foreach(node.key)
    {
        if(node.key[i] == key) return node.data[i];
            if(node.key[i] > key) return BTree_Search(point[i]->node);
    }
    return BTree_Search(point[i+1]->node);
}
data = BTree_Search(root, my_key);
```

###B-Tree和B+Tree区别
1.B+树内节点不存储数据，所有 data 存储在叶节点，因此查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)；
2.B+树叶节点两两相连，即每个叶子节点都有一个指针指向下一个叶子节点，可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找；
3.B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确；

###B-Tree索引适用的查询类型
适用的类型：

* 全值匹配
* 匹配最左前缀
* 匹配列前缀
* 匹配范围值

限制：
* 多个列组成索引时，要使用该索引需要从最左的那个索引列开始查找，即在WHERE中要按照索引中列的顺序查找；
* 多个列组成索引时，不能跳过索引中某个列，否则不会用到该索引，比如索引是(a, b, c)，而在查询时使用(b, c)；
* 多个列组成索引时，如果某个列使用了范围查询，则该列右边的列无法使用索引优化查找；


##2.哈希索引
基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。
MySQL中只有Memory引擎显示支持哈希索引。

###限制：

* 哈希索引只包含哈希值和行指针，所以不能使用索引中的值来避免读取行（覆盖索引中可以将需要查询的列添加到索引中，以此来避免读取索引之后还要回表）；
* 哈希索引数据无法根据列的值来排序，因为索引数据中保存的是哈希码；
* 哈希索引不支持部分匹配查找，因为哈希码是根据索引列的全部内容来计算哈希值；
* 哈希索引只支持等值比较查询：=、IN()、<=>，不支持范围查询；
* 哈希冲突很多时，维护索引需要很大的代价，如果从表中删除一行，需要遍历该行的哈希值中的数据链表的每一行，找到对应的行进行删除；

###自适应哈希索引adaptive hash index
在InnoDB中，如果某些索引值被使用得非常频繁，它会在内存中基于B-Tree索引之上再创建一个哈希索引。
这个功能是完全自动的内部行为，用户无法控制或配置。

###自定义哈希索引
用于要对某些数据比较长的列，可以增加一个冗余字段，用来保存该列的哈希值，然后对该列添加索引。
例子：

```mysql
CREATE TABLE pseudohash(
    id int unsigned NOT NULL auto_increment,
    url varchar(255) NOT NULL,
    url_crc int unsigned NOT NULL DEFAULT 0,
    PRIMARY KEY(id)
)
# 创建触发器来维护哈希
DELIMITER //
CREATE TRIGER pseudohash_cre_ins BEFORE INSERT ON pseudohash FOR EACH ROW BEGIN SET NEW.url_crc = crc32(NEW.URL);
END;
// 

CREATE TRIGER pseudohash_cre_upd BEFORE UPDATE ON pseudohash FOR EACH ROW BEGIN SET NEW.url_crc = crc32(NEW.URL);
END;
// 
DELIMITER ;
```
在查询的时候，要使用冗余的哈希值和对应的列值，否则在出现哈希冲突时，无法找到正确的那一行。


##3.空间数据索引R-Tree

##4.全文索引

##5.聚簇索引
InnoDB的聚簇索引，将完整的数据存放在索引的叶子页中。一般InnoDB会通过主键聚集数据，即被索引的列用的是主键列。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引。

InnoDB中的主键最好是使用自增，因为这样子在数据插入的时候会按照顺序插入。如果是其他值（随机或不是按顺序增长的），需要在插入的时候查找到一个合适的位置来保存该数据。这种形式会更加耗时。
###MyISAM和InnoDB中索引数据的分布
InnoDB的主键(聚簇)索引保存主键值和完整的数据。
其他非聚簇索引被称为**二级索引**。在二级索引中，会保存一个索引列及一个主键列。使用二级索引查找时，需要经过两次索引查找，第一次通过二级索引找到主键的值，再通过主键去查找数据。

MyISAM的索引中，索引的B-Tree叶子节点保存的是数据的物理行指针。

##6.覆盖索引
一个索引包含所有需要查询的字段的值，则称之为覆盖索引。查询可以通过在一个索引中完成，覆盖索引效率会比较高，主键查询是天然的覆盖索引。
可以用来解决InnoDB中二级索引每次查询都要查两次的问题，如果二级主键能够被覆盖查询，则可以避免对主键索引的二次查询。


http://blog.csdn.net/wwh578867817/article/details/50493940


##7.索引使用策略
###独立的列
独立的列指索引列不能是表达式的一部分，也不能是函数的参数

###前缀索引和索引选择性
索引选择性：不重复的索引值（也成为基数）和数据表的记录总数的比值。索引选择性越高则查询效率越高，因为选择性越高，表示在查询时能过滤掉更多的行。

当需要索引的列的数据很大时：

* 使用自定义哈希索引；
* 使用列的前某部分字符作为索引，即前缀索引；
对于BLOB、TEXT或者很长的VARCHAR，只能使用前缀索引，因为MySQL不允许索引这些列的完整长度。
前缀索引的长度很关键，必须保证有较高的选择性，同时又不能太长（以便节省空间）。尽可能使得前缀索引的选择性接近索引整个列，即前缀的基数应该接近于完整列的基数。

```mysql
# 查看列中最常见的数据
SELECT COUNT(*) AS cnt, column FROM table GROUP BY column ORDER BY cnt DESC LIMIT 10;

# 查看出现最频繁的列表前缀，先查看前3位
SELECT COUNT(*) AS cnt, LEFT(column, 3) AS pref FROM table GROUP BY pref ORDER BY cnt DESC LIMIT 10;

# 查看出现最频繁的列表前缀，先查看前7位
SELECT COUNT(*) AS cnt, LEFT(column, 7) AS pref FROM table GROUP BY pref ORDER BY cnt DESC LIMIT 10;

# 查看完整列的选择性
SELECT COUNT(DISTINCT column)/COUNT(*) FROM table;

# 查看不同位数的前缀的选择性
SELECT COUNT(DISTINCT LEFT(column, 3))/COUNT(*), 
    COUNT(DISTINCT LEFT(column, 4))/COUNT(*), 
    COUNT(DISTINCT LEFT(column, 5))/COUNT(*), 
    COUNT(DISTINCT LEFT(column, 6))/COUNT(*), 
    COUNT(DISTINCT LEFT(column, 7))/COUNT(*), 
    FROM table；

# 创建索引前缀，使用column的前n位来创建索引
ALTER TABLE table ADD KEY (column(n));
```

不足：
* 前缀索引无法使用GROUP BY或ORDER BY；
* 无法使用前缀索引做覆盖扫描

应用：
* 对session的保存可以取长度为8的前缀索引；
* 可以使用倒序来保存邮箱地址，然后使用前缀索引来查找某个域名下的邮箱

###多列索引
如果在查询时可能会用到多个字段作为条件，那应该按照一定顺序为这些字段创建一个索引，而不是每个字段都分开创建一个索引。否则在索引时可能触发合并索引（index merge），当使用EXPLAIN时看到合并索引，则表示需要对表结构或者查询进行优化。

###合适的索引顺序
当使用多个字段作为一个索引时，优先考虑将获取到的数据较小的字段放在前面。
如性别和年龄，年龄字段显然能过滤掉更多的数据，因此在创建索引时，年龄放在前面。

##8.使用索引扫描来做排序
MySQL中通过两种方式来产生有序的结果：

* 通过排序操作
* 按索引顺序扫描
如果EXPLAIN出来的type列的值为index，则说明MySQL使用了索引扫描来做排序。
当索引覆盖要查询的列时效率很高，但是如果不能覆盖则需要每扫描一条索引记录就都回表查询一次。

使用索引来排序的条件：

* 当索引的顺序和ORDER BY子句的顺序完全一致，并且所有的排序方向（倒序/正序）都一样时，才能够使用索引来对结果排序；
* 查询关联多张表时，只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序；
* ORDER BY子句需要满足索引的最左前缀要求。



