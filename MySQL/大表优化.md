# 大表优化

## 单表数据量
* 以整型为主的表，数据量千万级别以下；
* 以字符型为主的表，数据量五百万级别以下；
* 单表字段在20以内；

## 尽可能精确字段类型及长度
* 使用TINYINT、SMALLINT、MEDIUM_INT来替代INT，非负加上UNSIGNED；
* VARCHAR分配真正需要的长度；
* 使用枚举或者整数替代字符串类型；
* 尽量使用TIMESTAMP而非DATETIME；
* 避免使用NULL字段；
* 用整型来保存IP；

## 索引
* 针对WHERE/ORDERBY命令设计的字段简历索引；
* 避免在WHERE中对字段进行NULL值判断，会导致引擎使用全表扫描；
* 值分布很少的字段不适合简历索引，如性别这种只有两三个值的字段；
* 字符字段只建前缀索引，并且字符字段最好不要做主键；
* 不使用外键，通过程序来保证约束；
* 尽量不使用UNIQUE，通过程序来保证约束；
* 多字段索引时，注意左前缀原则；

## 查询
* 不在WHERE中做列运算，如：WHERE age + 10 = 10，包括函数、计算表达式等，`查询时尽可能将操作移至等号右边`；
* SQL语句尽可能简单，减少锁时间；
* 不使用SELECT *；
* OR改写成IN，OR的效率是n级别，IN的效率是log(n)级别，IN的个数控制在200以内；
* 避免使用%xxx式查询，会导致索引失效(xxx%式查询则不会；
* 尽量使用同类型比较，如'123'和'123'，123和123；
* 避免使用!=或<>，两者会导致引擎方式使用索引；
* 对于连续数值，使用BETWEEN不用IN；

## 引擎选择
MyISAM适合查询操作较多的表，InnoDB适合更新和插入操作较多的表。

### MyISAM
* 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排他锁；
* 不支持事务；
* 不支持外键；
* 不支持崩溃前后的安全恢复；
* 在表有读取查询的同时；支持往表中插入新纪录；
* 支持BLOB和TEXT的前500个字符索引，支持全文索引；
* 支持延迟更新索引，极大提升写入性能；
* 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用；

### InnoDB
* 支持行锁，采用MVCC来支持高并发；
* 支持事务；
* 支持外键；
* 支持崩溃前后的安全恢复；
* 不支持全文索引；


## 分区
表分区在底层是通过多个物理子表组成，在SQL层查询时需要带上分区条件的字段，否则会全表扫面。可通过EXPLAIN来查看某条SQL语句会落在哪些分区上，从而进行SQL优化。

### 分区优点
* “单表”存储更多的数据；
* 可对一个独立分区的数据进行增删、优化、检查和修复等；
* 部分查询只落在少数分区上，速度比较快；
* 分区表的数据可以分步在不同的物理设备上（？）；
* 可以使用分区来避免某些特殊瓶颈，如InnoDB单个索引互斥访问；
* 可以备份和恢复单个分区；

### 分区的限制/缺点
* 一个表最多只能有1024个分区；
* 如果分区字段中有主键或者唯一索引的字段，那么所有的主键和唯一索引都必须包含进来；
* 分区表无法使用外键约束；
* NULL值会使分区过滤无效；
* 所有分步必须使用相同的存储引擎；

### 分区类型
* RANGE分区
* LIST分区
* HASH分区
* KEY分区

### 适用场景
* 时间序列性较强，按时间分区；
* 有明显的访问热点，可讲这部分热点数据单独放到一个分区上，使得这个分区的数据能够缓存在内存上；


## 分库分表
### 垂直拆分
根据数据的相关性进行拆分，如一个库中既有用户数据，又有订单数据，那么可以拆分成用户库和订单库。
垂直分表是将一个多字段的大表按常用字段和非常用字段进行拆分，每个表中的数据记录数一般情况下是相同，通过主键关联。

#### 垂直拆分优点
* 行数据变小，一个数据块（Block）能存放更多的数据，在查询时能减少I/O次数；
* 拆分时字段的访问频率进行拆分，最大化利用Cache；


#### 垂直拆分缺点
* 主键冗余；
* 需要联表查询时会增加CPU开销；
* 依然存在单表数据量过大的问题；
* 事务处理复杂；

### 水平拆分
通过某种策略，将数据分片来存储，每片数据会分散到不同的表或库中。
库内分表，只是单纯解决单个表数据量过大的问题，由于没有把表数据分布到不同的机器上，因此对于没有减轻MySQL服务器的压力。所有的连接都在竞争同一个物理机上的IO、CPU、网络等资源。

#### 水平拆分优点
* 不存在单库大数据和高并发的性能瓶颈；
* 提高系统的稳定性和负载能力；

#### 水平拆分缺点
* 分片事务一致性难以解决；
* 跨节点Join性能差，逻辑复杂；
* 数据多次扩展难度和维护量极大；

#### 分片原则
* 尽可能优先做单表优化；
* 分片数量尽量少；
* 需要考虑数据的增长模式、数据的访问模式、分片关联性以及分片扩容，范围分片、枚举分片、一致性Hash分片都有利于扩容；
* 避免在一个事务中的SQL跨越多个分片；
