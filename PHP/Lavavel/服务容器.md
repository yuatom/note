# 服务容器
Laravel中管理类依赖的工具。
通过构造器或setter方法注入类依赖，即依赖注入。
##例子

```php
<?php namespace App\Handlers\Commands;

use App\User;
use App\Commands\PurchasePodcastCommand;
use Illuminate\Contracts\Mail\Mailer;

class PurchasePodcastHandler {

    /**
     * 一个发信功能的实现
     */
    protected $mailer;

    /**
     * 创建一个新的实例
     *
     * @param  Mailer  $mailer
     * @return void
     */
    public function __construct(Mailer $mailer)
    {
        $this->mailer = $mailer;
    }

    /**
     * 购买一个播客节目
     *
     * @param  PurchasePodcastCommand  $command
     * @return void
     */
    public function handle(PurchasePodcastCommand $command)
    {
        //
    }

}
```
以上例子，当播客被购买时， PurchasePodcast 命令处理器需要发送一封电子邮件。

##基本用法
###绑定
几乎所有的服务容器绑定都是在`服务提供者`中完成。
容器并不需要被告知如何构建对象，因为它会使用 PHP 的反射服务自动解析出具体的对象。
####注册基本解析器
在服务提供者中，通过`$this->app`访问容器。
服务容器注册依赖有几种方式，包括**闭包回调**和**绑定实例的接口**。

```php
// 闭包回调方式，被注册至容器的闭包解析器包含一个 key (通常用类名称) 和一个有返回值的闭包:
// 容器本身作为解析器的一个参数，然后可以使用该容器来解析正在构建的对象的子依赖。
$this->app->bind('FooBar', function($app)
{
    return new FooBar($app['SomethingElse']);
});
```

####单例绑定，$this->app->singleton()方法
绑定后该对象只会被解析一次，在此之后对容器的调用都将返回同一个实例。

```php
$this->app->singleton('FooBar', function($app)
{
    return new FooBar($app['SomethingElse']);
});
```

####绑定实例，$this->app->instance()方法
绑定一个已经存在的实例，接下来将总返回该实例。

```php
$fooBar = new FooBar(new SomethingElse);

$this->app->instance('FooBar', $fooBar);
```

####接口绑定
假设有一个`EventPusher`接口及它的一个实现`RedisEventPusher`，可将这两者绑定起来。
当一个类需要`EventPusher`的实现时，会自动注入`RedisEventPusher`：

```php
// 绑定
$this->app->bind('App\Contracts\EventPusher', 'App\Services\RedisEventPusher');

// 自动注入实现
use App\Contracts\EventPusher;
/**
 * 创建一个新的类实例
 *
 * @param  EventPusher  $pusher
 * @return void
 */
public function __construct(EventPusher $pusher){
    $this->pusher = $pusher;
}
```

####上下文绑定
在不同的上下文中调用同一个接口时注入不同的实现类。

```php
// 注入实现类
$this->app->when('App\Handlers\Commands\CreateOrderHandler')
          ->needs('App\Contracts\EventPusher')
          ->give('App\Services\PubNubEventPusher');
          
// 注入方法
$this->app->when('App\Handlers\Commands\CreateOrderHandler')
    ->needs('App\Contracts\EventPusher')
    ->give(function () {
        // Resolve dependency...
    });
```

####绑定原始值
有时候你可能有一个获取若干注入类的类，但还需要一个注入的原始值，比如整型数据，你可以轻松使用上下文绑定来注入指定类所需要的任何值：

```php
$this->app->when('App\Handlers\Commands\CreateOrderHandler')
    ->needs('$maxOrderCount')
    ->give(10);
```

###标签
有时要解析某个分类下的所有绑定，可用`$this->app->tag()`给这些绑定打上一个标签，之后再用`$app->tagged()`全部解析。

```php
// 绑定
$this->app->bind('SpeedReport', function () {
    //
});

$this->app->bind('MemoryReport', function () {
    //
});

// 打标签
$this->app->tag(['SpeedReport', 'MemoryReport'], 'reports');

// 解析
$this->app->bind('ReportAggregator', function ($app) {
    return new ReportAggregator($app->tagged('reports'));
});
```

###解析
从容器中取出对象，有以下方式：
>* 使用make方法，参数为要解析的类名或接口名

```php
$fooBar = $this->app->make('FooBar');
```

>* 数组形式访问，因为实现了 PHP 的 ArrayAccess 接口

```php
$fooBar = $this->app['FooBar'];
```
>* 类型提示，该方式最常用，简单的通过在类的构造函数中对依赖进行类型提示来从容器中解析对象，包括控制器、事件监听器、队列任务、中间件等都是通过这种方式。

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Routing\Controller;
use App\Users\Repository as UserRepository;

class UserController extends Controller{
    /**
     * 用户仓库实例
     */
    protected $users;

    /**
     * 创建一个控制器实例
     *
     * @param  UserRepository  $users
     * @return void
     */
    public function __construct(UserRepository $users)
    {
        $this->users = $users;
    }

    /**
     * 通过指定ID显示用户
     *
     * @param  int  $id
     * @return Response
     */
    public function show($id)
    {
        //
    }
}
```

##容器事件
服务容器在每一次解析对象时都会触发一个事件，可以使用 resolving 方法监听该事件：

```php
$this->app->resolving(function ($object, $app) {
    // 容器解析所有类型对象时调用
});

$this->app->resolving(function (FooBar $fooBar, $app) {
    // 容器解析“FooBar”对象时调用
});
```
被解析的对象将会传递给回调，从而允许你在对象被传递给消费者之前为其设置额外属性。


