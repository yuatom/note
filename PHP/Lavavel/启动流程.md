# 启动流程
## `public/index.php`

### 1. 加载`bootstrap/autoload.php`

```php
define('LARAVEL_START', microtime(true));

/*
|--------------------------------------------------------------------------
| Register The Composer Auto Loader
|--------------------------------------------------------------------------
|
| Composer provides a convenient, automatically generated class loader
| for our application. We just need to utilize it! We'll require it
| into the script here so that we do not have to worry about the
| loading of any our classes "manually". Feels great to relax.
|
*/

require __DIR__.'/../vendor/autoload.php';

/*
|--------------------------------------------------------------------------
| Include The Compiled Class File
|--------------------------------------------------------------------------
|
| To dramatically increase your application's performance, you may use a
| compiled class file which contains all of the classes commonly used
| by a request. The Artisan "optimize" is used to create this file.
|
*/

$compiledPath = __DIR__.'/cache/compiled.php';

if (file_exists($compiledPath)) {
    require $compiledPath;
}
```

#### 1.1. 加载`vendor/autoload.php`

```php
// autoload.php @generated by Composer

require_once __DIR__ . '/composer' . '/autoload_real.php';

return ComposerAutoloaderInit01a6d04b777637d7c749513aeca6a1e0::getLoader();
```

##### 1.1.1. 加载`vender/composer/autoload_real.php`

`autoload_real.php`文件中定义了`ComposerAutoloaderInitxxx`类，后面为该类的文件hash，避免和其他类名冲突。

##### 1.1.2. 执行`ComposerAutoloaderInitxxxx::getLoader()`并返回`\Composer\Autoload\ClassLoader`对象，该类在`vender/composer/autoload_real.php`文件中定义。

`vender/composer/autoload_real.php`

```php
class ComposerAutoloaderInit01a6d04b777637d7c749513aeca6a1e0
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            // 加载vendor/composer/Classloader.php
            require __DIR__ . '/ClassLoader.php';
        }
    }

    public static function getLoader()
    {
        // 单例
        if (null !== self::$loader) {
            return self::$loader;
        }

        // 注册loadClassLoader方法到autoload
        spl_autoload_register(array('ComposerAutoloaderInit01a6d04b777637d7c749513aeca6a1e0', 'loadClassLoader'), true, true);

        // 实例化\Composer\Autoload\ClassLoader，调用loadClassLoader
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();

        // 从autoload注销loadClassLoader方法
        spl_autoload_unregister(array('ComposerAutoloaderInit01a6d04b777637d7c749513aeca6a1e0', 'loadClassLoader'));
        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
        if ($useStaticLoader) {
            // 静态初始化，使用原声的opcache对静态数组的优化，该文件是composer生成的静态数组文件
            // 其中将命名空间和所在目录做了映射
            require_once __DIR__ . '/autoload_static.php';

            // 返回一个匿名函数，在该匿名函数中对\Composer\Autoload\ClassLoader的变量进行赋值
            call_user_func(\Composer\Autoload\ComposerStaticInit3752c29392b38d3129b67df57c6563bf::getInitializer($loader));
        } else {
            // 符合psr0的类命名空间和路径映射起来
            $map = require __DIR__ . '/autoload_namespaces.php';
            foreach ($map as $namespace => $path) {
                $loader->set($namespace, $path);
            }

            // 符合psr4的类命名空间和路径映射起来
            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }

            // 将类名与类文件路径对应的数组保存到classMap属性，这些类的命名不符合以上两种规范
            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                $loader->addClassMap($classMap);
            }
        }

        // 注册autoload方法到到ClassLoader类的loadClass方法上
        $loader->register(true);

        // 返回一些定义公共方法的文件路径，该文件由composer生成，键为随机字符串，键值为文件路径
        $includeFiles = require __DIR__ . '/autoload_files.php';
        // 加载文件
        foreach ($includeFiles as $fileIdentifier => $file) {
            composerRequire01a6d04b777637d7c749513aeca6a1e0($fileIdentifier, $file);
        }

        return $loader;
    }
}

// 加载文件的方法，定义一个变量来记录文件是否加载过
function composerRequire01a6d04b777637d7c749513aeca6a1e0($fileIdentifier, $file)
{
    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
        require $file;

        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;
    }
}
```

`vender/composer/autoload_static.php`

```php
    public static function getInitializer(ClassLoader $loader)
    {
        // 返回一个匿名函数，指定了scope为\Composer\Autoload\ClassLoader，对loader的private变量赋值
        return \Closure::bind(function () use ($loader) {
            $loader->prefixLengthsPsr4 = ComposerStaticInit3752c29392b38d3129b67df57c6563bf::$prefixLengthsPsr4;
            $loader->prefixDirsPsr4 = ComposerStaticInit3752c29392b38d3129b67df57c6563bf::$prefixDirsPsr4;
            $loader->prefixesPsr0 = ComposerStaticInit3752c29392b38d3129b67df57c6563bf::$prefixesPsr0;
            $loader->classMap = ComposerStaticInit3752c29392b38d3129b67df57c6563bf::$classMap;

        }, null, ClassLoader::class);
    }
```

静态数组映射中：
##### 对于psr0：
将类路径添加到Classloader类的prefixesPsr0属性这个键值二维数组中，第一维键值为类命名空间的首字母，第二维键值为命名空间，键值是将路径转换为数组类型。

##### 对于psr4：
>* 将psr4规范命名的类的类名长度（包括命名空间）添加属性prefixLengthsPsr4这个二维数组，键值命名和prefixesPsr0规则一致，键值为类名长度；
>* 将路径保存到prefixDirsPsr4这个一维数组中，键为类名，键值为路径；

根据该长度来定位类所在的位置，例如：长度数组中：`'phpDocumentor\\Reflection\\' => 25，`，路径数组中：`'phpDocumentor\\Reflection\\' => array(0 => __DIR__ . '/..' . '/phpdocumentor/reflection-common/src',)`，加载`phpDocumentor\Reflection\Element`类时，查找到命名空间长度为`25`，那么会将前面25个字符替换为对应的路径，即，将`phpDocumentor\Reflection\`替换为`/phpdocumentor/reflection-common/src`，寻找的结果为/phpdocumentor/reflection-common/src/Element.php


`vender/composer/ClassLoader.php`

```php
    /**
     * 注册类加载方法
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    /**
     * 加载给定的类/接口
     * Loads the given class or interface.
     *
     * @param  string    $class The name of the class
     * @return bool|null True if loaded, null otherwise
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            includeFile($file);

            return true;
        }
    }


    /**
     * 查找类所在的文件
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|false The path if found, false otherwise
     */
    public function findFile($class)
    {
        // class map lookup
        // 如果加载过，直接返回
        if (isset($this->classMap[$class])) {
            return $this->classMap[$class];
        }
        // 如果查找过，加载不到，直接返回false
        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
            return false;
        }
        if (null !== $this->apcuPrefix) {
            $file = apcu_fetch($this->apcuPrefix.$class, $hit);
            if ($hit) {
                return $file;
            }
        }

        $file = $this->findFileWithExtension($class, '.php');

        // Search for Hack files if we are running on HHVM
        if (false === $file && defined('HHVM_VERSION')) {
            $file = $this->findFileWithExtension($class, '.hh');
        }

        if (null !== $this->apcuPrefix) {
            apcu_add($this->apcuPrefix.$class, $file);
        }

        if (false === $file) {
            // Remember that this class does not exist.
            $this->missingClasses[$class] = true;
        }

        return $file;
    }


    // 查找指定后缀名的类
    private function findFileWithExtension($class, $ext)
    {
        // PSR-4 lookup
        // psr4，将\替换为文件分隔符，并拼上后缀名
        // 如类为phpDocumentor\Reflection\Element，替换为phpDocumentor/Reflection/Element.php
        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

        // 取第一个字符，得到p
        $first = $class[0];
        // 判断psr4长度数组中是否由该字符
        if (isset($this->prefixLengthsPsr4[$first])) {
            $subPath = $class;
            while (false !== $lastPos = strrpos($subPath, '\\')) {
                // 截取命名空间，$subPath = 'phpDocumentor\Reflection'
                $subPath = substr($subPath, 0, $lastPos);
                // $search = 'phpDocumentor\Reflection\'
                $search = $subPath.'\\';
                // 判断psr4中该命名空间的路径
                if (isset($this->prefixDirsPsr4[$search])) {
                    // 遍历每一个路径，根据长度进行替换
                    // 假如长度为25，即将phpDocumentor/Reflection/Element.php前25个字符替换为空
                    // 然后再前面拼上路径
                    foreach ($this->prefixDirsPsr4[$search] as $dir) {
                        $length = $this->prefixLengthsPsr4[$first][$search];
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-4 fallback dirs
        foreach ($this->fallbackDirsPsr4 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
                return $file;
            }
        }

        // PSR-0 lookup
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
        } else {
            // PEAR-like class name
            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
        }

        if (isset($this->prefixesPsr0[$first])) {
            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($dirs as $dir) {
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-0 fallback dirs
        foreach ($this->fallbackDirsPsr0 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                return $file;
            }
        }

        // PSR-0 include paths.
        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
            return $file;
        }

        return false;
    }
```

### 2. 加载`bootstrap/app.php`文件

```php
// 传入项目根目录，实例化`Illuminate\Foundation\Application`对象
$app = new Illuminate\Foundation\Application(
    realpath(__DIR__.'/../')
);

/*
|--------------------------------------------------------------------------
| Bind Important Interfaces
|--------------------------------------------------------------------------
|
| Next, we need to bind some important interfaces into the container so
| we will be able to resolve them when needed. The kernels serve the
| incoming requests to this application from both the web and CLI.
|
*/

$app->singleton(
    Illuminate\Contracts\Http\Kernel::class,
    App\Http\Kernel::class
);

$app->singleton(
    Illuminate\Contracts\Console\Kernel::class,
    App\Console\Kernel::class
);

$app->singleton(
    Illuminate\Contracts\Debug\ExceptionHandler::class,
    App\Exceptions\Handler::class
);

/*
|--------------------------------------------------------------------------
| Return The Application
|--------------------------------------------------------------------------
|
| This script returns the application instance. The instance is given to
| the calling script so we can separate the building of the instances
| from the actual running of the application and sending responses.
|
*/

return $app;
```
#### 2.1. 实例化`Illuminate\Foundation\Application`对象

```php
// 传入项目路径
public function __construct($basePath = null)
    {
        // 注册基本的绑定
        // 1把当前对象赋值给Illuminate\Foundation\Application的静态属性$instance
        // 2把当前对象与容器中的app别名关联起来，即$this->instances['app']
        // 3把当前对象与容器中的Illuminate\Container\Container别名关联起来，
        $this->registerBaseBindings();

        // 注册基本的服务提供者
        // 1EventServiceProvider
        // 2RoutingServiceProvider
        $this->registerBaseServiceProviders();

        // 注册核心的容器组件别名
        // 1将核心的类及别名以键值数组硬编码到该registerCoreContainerAliases方法中的一个变量
        // 2遍历1中的变量，添加到$this->aliases属性中
        $this->registerCoreContainerAliases();

        if ($basePath) {
            // 设置$this->basePath属性
            // 绑定$this->instances['path']为$basePath/app
            // 设置['base', 'config', 'database', 'lang', 'public', 'storage']的路径
            // 遍历设置的例子：$this->instances['path.base'] = $this->basePath();
            $this->setBasePath($basePath);
        }
    }

/**
* Register the basic bindings into the container.
*
* @return void
*/
protected function registerBaseBindings()
{
    // 将app实例赋值给自己的instance属性
   static::setInstance($this);

   $this->instance('app', $this);

   $this->instance('Illuminate\Container\Container', $this);
}

/**
* Set the shared instance of the container.
*
* @param  \Illuminate\Contracts\Container\Container  $container
* @return void
*/
public static function setInstance(ContainerContract $container)
{
   static::$instance = $container;
}

/**
* Register an existing instance as shared in the container.
*
* @param  string  $abstract
* @param  mixed   $instance
* @return void
*/
public function instance($abstract, $instance)
{
    // 如果传入的抽象名称是字符串，则去掉左边的//符号
   $abstract = $this->normalize($abstract);

   // First, we will extract the alias from the abstract if it is an array so we
   // are using the correct name when binding the type. If we get an alias it
   // will be registered with the container so we can resolve it out later.
   if (is_array($abstract)) {
        // 如果传入的抽象名称数组，将其键赋值给abstract，键值赋值给alias
       list($abstract, $alias) = $this->extractAlias($abstract);
        // 将$abstract为键值、$alias为键名，添加到当前对象的aliases数组属性中
       $this->alias($abstract, $alias);
   }

   unset($this->aliases[$abstract]);

   // We'll check to determine if this type has been bound before, and if it has
   // we will fire the rebound callbacks registered with the container and it
   // can be updated with consuming classes that have gotten resolved here.
   // 获取是否已经绑定
   $bound = $this->bound($abstract);

    // 将抽象名称作为键，传入的实例作为键值添加到instances属性
   $this->instances[$abstract] = $instance;

    // 如果已经绑定过，则重新绑定更新实例
   if ($bound) {
       $this->rebound($abstract);
   }
}

/**
 * Fire the "rebound" callbacks for the given abstract type.
 *
 * @param  string  $abstract
 * @return void
 */
protected function rebound($abstract)
{
    // 从容器中获取
   $instance = $this->make($abstract);
    // 调用重新绑定的回调
   foreach ($this->getReboundCallbacks($abstract) as $callback) {
       call_user_func($callback, $this, $instance);
   }
}

/**
 * Resolve the given type from the container.
 *
 * @param  string  $abstract
 * @param  array   $parameters
 * @return mixed
 */
public function make($abstract, array $parameters = [])
{
    // 判断$this->aliases数组属性中是否存在该别名，有则返回该别名
   $abstract = $this->getAlias($this->normalize($abstract));

   // If an instance of the type is currently being managed as a singleton we'll
   // just return an existing instance instead of instantiating new instances
   // so the developer can keep using the same objects instance every time.
   // 如果当前名称的对象作为单例，则不去实例化而是直接返回当前名称的对象，
   if (isset($this->instances[$abstract])) {
       return $this->instances[$abstract];
   }

    // 获取concrete类型（concrete type)
   $concrete = $this->getConcrete($abstract);

   // We're ready to instantiate an instance of the concrete type registered for
   // the binding. This will instantiate the types, as well as resolve any of
   // its "nested" dependencies recursively until all have gotten resolved.
   // 是否可以创建：两个参数全等||参数concrete是一个闭包
   if ($this->isBuildable($concrete, $abstract)) {
        // 构建实例化对象需要的依赖并实例化
       $object = $this->build($concrete, $parameters);
   } else {
        // 从容器中获取
       $object = $this->make($concrete, $parameters);
   }

   // If we defined any extenders for this type, we'll need to spin through them
   // and apply them to the object being built. This allows for the extension
   // of services, such as changing configuration or decorating the object.
   // 获取并执行对象的扩展闭包
   foreach ($this->getExtenders($abstract) as $extender) {
       $object = $extender($object, $this);
   }

   // If the requested type is registered as a singleton we'll want to cache off
   // the instances in "memory" so we can return it later without creating an
   // entirely new instance of an object on each subsequent request for it.
   // 是否是共享
   // 1$this->instances存在该元素
   // 2$this->bindings中该元素存在键名为['shared']的元素值为true
   if ($this->isShared($abstract)) {
        // 共享的话将实力添加到$this->instances数组中
       $this->instances[$abstract] = $object;
   }
    // 调用实例化的对象的回调
    // app的$globalResolvingCallbacks数组属性，全局回调
    // app的$resolvingCallbacks数组属性，
    // app的$globalAfterResolvingCallbacks数组属性
    // app的$afterResolvingCallbacks数组属性
   $this->fireResolvingCallbacks($abstract, $object);
    // 标记该对象已处理
   $this->resolved[$abstract] = true;

   return $object;
}


/**
 * Get the concrete type for a given abstract.
 *
 * @param  string  $abstract
 * @return mixed   $concrete
 */
protected function getConcrete($abstract)
{
    // 如果上下文存在该名称的类型，判断$this->buildStack这个属性中有没有
   if (! is_null($concrete = $this->getContextualConcrete($abstract))) {
       return $concrete;
   }

   // If we don't have a registered resolver or concrete for the type, we'll just
   // assume each type is a concrete name and will attempt to resolve it as is
   // since the container should be able to resolve concretes automatically.
   // 如果从没绑定过这个名称的concrete，则直接返回当前名称
   if (! isset($this->bindings[$abstract])) {
       return $abstract;
   }
    // 绑定过该名称的concrete，则返回concrete
   return $this->bindings[$abstract]['concrete'];
}


/**
 * Instantiate a concrete instance of the given type.
 *
 * @param  string  $concrete
 * @param  array   $parameters
 * @return mixed
 *
 * @throws \Illuminate\Contracts\Container\BindingResolutionException
 */
public function build($concrete, array $parameters = [])
{
   // If the concrete type is actually a Closure, we will just execute it and
   // hand back the results of the functions, which allows functions to be
   // used as resolvers for more fine-tuned resolution of these objects.
   // 如果是闭包concrete，则调用
   if ($concrete instanceof Closure) {
       return $concrete($this, $parameters);
   }
    // 获取concrete类的反射
   $reflector = new ReflectionClass($concrete);

   // If the type is not instantiable, the developer is attempting to resolve
   // an abstract type such as an Interface of Abstract Class and there is
   // no binding registered for the abstractions so we need to bail out.
   if (! $reflector->isInstantiable()) {
    // 不能实例化，抛出异常
       if (! empty($this->buildStack)) {
           $previous = implode(', ', $this->buildStack);
           $message = "Target [$concrete] is not instantiable while building [$previous].";
       } else {
           $message = "Target [$concrete] is not instantiable.";
       }

       throw new BindingResolutionException($message);
   }
    // 将当前类添加到$this->buildStack数组
   $this->buildStack[] = $concrete;
    // 获取构造方法
   $constructor = $reflector->getConstructor();

   // If there are no constructors, that means there are no dependencies then
   // we can just resolve the instances of the objects right away, without
   // resolving any other types or dependencies out of these containers.
   if (is_null($constructor)) {
        // 如果构造方法为null，则从$this->buildStack删除刚刚添加的concrete
       array_pop($this->buildStack);
        // 返回当前concrete的实例
       return new $concrete;
   }
    // 构造方法不为空，则获取构造方法需要的依赖
   $dependencies = $constructor->getParameters();

   // Once we have all the constructor's parameters we can create each of the
   // dependency instances and then use the reflection instances to make a
   // new instance of this class, injecting the created dependencies in.
   // 将数组转换为键值对的形式，如果键值的键是数字，则用对应顺序的依赖名作键名
   $parameters = $this->keyParametersByArgument(
       $dependencies, $parameters
   );
    // 获取实例化需要的类型提示的对象
   $instances = $this->getDependencies(
       $dependencies, $parameters
   );
    // 从$this->buildStack删除刚刚添加的concrete
   array_pop($this->buildStack);
    // 传入实例化需要的参数并实例化
   return $reflector->newInstanceArgs($instances);
}

/**
 * Resolve all of the dependencies from the ReflectionParameters.
 *
 * @param  array  $parameters
 * @param  array  $primitives
 * @return array
 */
protected function getDependencies(array $parameters, array $primitives = [])
{
   $dependencies = [];

   foreach ($parameters as $parameter) {
        // 获取依赖（类型提示）的类
       $dependency = $parameter->getClass();

       // If the class is null, it means the dependency is a string or some other
       // primitive type which we can not resolve since it is not a class and
       // we will just bomb out with an error since we have no-where to go.
       if (array_key_exists($parameter->name, $primitives)) {
            // 如果依赖的类的对象在参数中存在，则将该对象放入要返回的依赖数组
           $dependencies[] = $primitives[$parameter->name];
       } elseif (is_null($dependency)) {
            // 处理类名为null的情况，则参数可能是基本类型
            // 1如果是闭包，则调用闭包并返回结果
            // 2如果基本类型，有默认值的情况下返回默认值
            // 3抛出异常
           $dependencies[] = $this->resolveNonClass($parameter);
       } else {
            // 不为null的情况下，尝试在容器中获取，失败的花抛出异常
           $dependencies[] = $this->resolveClass($parameter);
       }
   }

   return $dependencies;
}

**
 * Register all of the base service providers.
 *
 * @return void
 */
protected function registerBaseServiceProviders()
{
   $this->register(new EventServiceProvider($this));

   $this->register(new RoutingServiceProvider($this));
}

/**
 * Register a service provider with the application.
 *
 * @param  \Illuminate\Support\ServiceProvider|string  $provider
 * @param  array  $options
 * @param  bool   $force
 * @return \Illuminate\Support\ServiceProvider
 */
public function register($provider, $options = [], $force = false)
{
    // 如果已经注册，则返回已注册的
   if (($registered = $this->getProvider($provider)) && ! $force) {
       return $registered;
   }

   // If the given "provider" is a string, we will resolve it, passing in the
   // application instance automatically for the developer. This is simply
   // a more convenient way of specifying your service provider classes.
   if (is_string($provider)) {
        // 参数是字符串，直接实例化，return new $provider($this);
       $provider = $this->resolveProviderClass($provider);
   }
    // 调用服务提供者的register()方法，EventServiceProvider会将'event‘与Illuminate\Events\Dispatcher绑定，后面markAsRegistered方法会用到event
   $provider->register();

   // Once we have registered the service we will iterate through the options
   // and set each of them on the application so they will be available on
   // the actual loading of the service objects and for developer usage.
   // 遍历保存选项
   foreach ($options as $key => $value) {
       $this[$key] = $value;
   }
    // 标记为已注册
    // 1serviceProviders数组属性中添加该提供者
    // 2loadedProviders数组属性中，以该服务提供者的类名的键名，键值为true
   $this->markAsRegistered($provider);

   // If the application has already booted, we will call this boot method on
   // the provider class so it has an opportunity to do its boot logic and
   // will be ready for any usage by the developer's application logics.
   if ($this->booted) {
        // 应用启动后，调用服务提供者的boot方法
       $this->bootProvider($provider);
   }

   return $provider;
}

/**
 * Get the registered service provider instance if it exists.
 *
 * @param  \Illuminate\Support\ServiceProvider|string  $provider
 * @return \Illuminate\Support\ServiceProvider|null
 */
public function getProvider($provider)
{
    // 返回类名
   $name = is_string($provider) ? $provider : get_class($provider);
    // $this->serviceProviders存在要注册的服务提供者，则返回该提供者，否则返回null
   return Arr::first($this->serviceProviders, function ($key, $value) use ($name) {
       return $value instanceof $name;
   });
}

**
 * Mark the given provider as registered.
 *
 * @param  \Illuminate\Support\ServiceProvider  $provider
 * @return void
 */
protected function markAsRegistered($provider)
{
    // $this['events']，在EventServiceProvider的register方法中，将Illuminate\Events\Dispatcher与$this['events']单例绑定
    // 如果是事件监听的类，启动一个事件监听
   $this['events']->fire($class = get_class($provider), [$provider]);

   $this->serviceProviders[] = $provider;

   $this->loadedProviders[$class] = true;
}

```
Illuminate\Events\Dispatcher

```php
/**
 * Fire an event and call the listeners.
 *
 * @param  string|object  $event
 * @param  mixed  $payload
 * @param  bool  $halt
 * @return array|null
 */
public function fire($event, $payload = [], $halt = false)
{
   // When the given "event" is actually an object we will assume it is an event
   // object and use the class as the event name and this event itself as the
   // payload to the handler, which makes object based events quite simple.
   if (is_object($event)) {
       list($payload, $event) = [[$event], get_class($event)];
   }

   $responses = [];

   // If an array is not given to us as the payload, we will turn it into one so
   // we can easily use call_user_func_array on the listeners, passing in the
   // payload to each of them so that they receive each of these arguments.
   if (! is_array($payload)) {
       $payload = [$payload];
   }
    // 将对象添加到启动的数组中
   $this->firing[] = $event;

   if (isset($payload[0]) && $payload[0] instanceof ShouldBroadcast) {
        // 如果实现了ShouldBroadcast接口，则广播出去
       $this->broadcastEvent($payload[0]);
   }
    // 获取事件对象中的监听，遍历回调
   foreach ($this->getListeners($event) as $listener) {
       $response = call_user_func_array($listener, $payload);

       // If a response is returned from the listener and event halting is enabled
       // we will just return this response, and not call the rest of the event
       // listeners. Otherwise we will add the response on the response list.
       if (! is_null($response) && $halt) {
           array_pop($this->firing);

           return $response;
       }

       // If a boolean false is returned from a listener, we will stop propagating
       // the event to any further listeners down in the chain, else we keep on
       // looping through the listeners and firing every one in our sequence.
       if ($response === false) {
           break;
       }

       $responses[] = $response;
   }

   array_pop($this->firing);

   return $halt ? null : $responses;
}
```


#### 2.2. 进行了接口实现的绑定：
>* `Illuminate\Contracts\Http\Kernel::class`接口与`App\Http\Kernel::class`实现；
>* `Illuminate\Contracts\Console\Kernel::class`接口与`App\Console\Kernel::class`实现；
>* `Illuminate\Contracts\Debug\ExceptionHandler::class`接口与`App\Exceptions\Handler::class`实现；

```php
/**
 * Register a shared binding in the container.
 *
 * @param  string|array  $abstract
 * @param  \Closure|string|null  $concrete
 * @return void
 */
public function singleton($abstract, $concrete = null)
{
   $this->bind($abstract, $concrete, true);
}

/**
 * Register a binding with the container.
 *
 * @param  string|array  $abstract
 * @param  \Closure|string|null  $concrete
 * @param  bool  $shared
 * @return void
 */
public function bind($abstract, $concrete = null, $shared = false)
{
   $abstract = $this->normalize($abstract);

   $concrete = $this->normalize($concrete);

   // If the given types are actually an array, we will assume an alias is being
   // defined and will grab this "real" abstract class name and register this
   // alias with the container so that it can be used as a shortcut for it.
   if (is_array($abstract)) {
       list($abstract, $alias) = $this->extractAlias($abstract);

       $this->alias($abstract, $alias);
   }

   // If no concrete type was given, we will simply set the concrete type to the
   // abstract type. This will allow concrete type to be registered as shared
   // without being forced to state their classes in both of the parameter.
   $this->dropStaleInstances($abstract);

   if (is_null($concrete)) {
       $concrete = $abstract;
   }

   // If the factory is not a Closure, it means it is just a class name which is
   // bound into this container to the abstract type and we will just wrap it
   // up inside its own Closure to give us more convenience when extending.
   if (! $concrete instanceof Closure) {
       $concrete = $this->getClosure($abstract, $concrete);
   }
    // 以变量名为键名，以变量值为键值，赋值给数组
   $this->bindings[$abstract] = compact('concrete', 'shared');

   // If the abstract type was already resolved in this container we'll fire the
   // rebound listener so that any objects which have already gotten resolved
   // can have their copy of the object updated via the listener callbacks.
   if ($this->resolved($abstract)) {
       $this->rebound($abstract);
   }
}

```
#### 2.3. 返回Application对象

### 3. 处理请求
#### 3.1. 从容器中获取`Illuminate\Contracts\Http\Kernel::class`的实例，`App\Http\Kernel::class`的对象
#### 3.2. 调用`Kernel->handle()`方法，处理请求

`public/index.php`

```php
$kernel = $app->make(Illuminate\Contracts\Http\Kernel::class);
$response = $kernel->handle(
    $request = Illuminate\Http\Request::capture()
);
```

`Illuminate\Http\Request`

```php
/**
 * Create a new Illuminate HTTP request from server variables.
 *
 * @return static
 */
public static function capture()
{
    // 将$httpMethodParameterOverride设置为true，表单的POST方法可以被改写成POST或DELETE
   static::enableHttpMethodParameterOverride();
   // 从PHP的全局变量中获取数据创建Symfony请求实例，包括$_SERVER、$_GET、$_POST、$_COOKIE、$_FILES
   // 从Symfony请求实例中创建Illuminate请求
   return static::createFromBase(SymfonyRequest::createFromGlobals());
}

```

`App\Http\Kernel extends Illuminate\Foundation\Http\Kernel`

```php
    /**
     * Handle an incoming HTTP request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function handle($request)
    {
        try {
            // 将$httpMethodParameterOverride设置为true，表单的POST方法可以被改写成POST或DELETE
            $request->enableHttpMethodParameterOverride();
            // 通过路由将请求发送到指定控制器
            $response = $this->sendRequestThroughRouter($request);
        } catch (Exception $e) {
            $this->reportException($e);

            $response = $this->renderException($request, $e);
        } catch (Throwable $e) {
            $this->reportException($e = new FatalThrowableError($e));

            $response = $this->renderException($request, $e);
        }

        $this->app['events']->fire('kernel.handled', [$request, $response]);

        return $response;
    }

        /**
     * Send the given request through the middleware / router.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    protected function sendRequestThroughRouter($request)
    {
        // 将当期请求与容器中的request绑定
        $this->app->instance('request', $request);
        // 清除Facade的静态属性$resolvedInstance中键为request的元素
        Facade::clearResolvedInstance('request');
        // 启动加载应用程序需要的类和事件监听
        $this->bootstrap();
        // 发送处理请求
        // 1实例一个Pipeline实例
        // 2发送请求，即将$request赋值给Pipeline->passable属性
        // 3传递中间件，在实例化Kernel的时候会将全局中间件和群组中间加载进该实例中
        // 4分发请求给路由，路由Illuminate\Routing\Router来处理请求
        return (new Pipeline($this->app))
                    ->send($request)
                    ->through($this->app->shouldSkipMiddleware() ? [] : $this->middleware)
                    ->then($this->dispatchToRouter());
    }


    /**
     * Bootstrap the application for HTTP requests.
     *
     * @return void
     */
    public function bootstrap()
    {
        if (! $this->app->hasBeenBootstrapped()) {
            // 启动应用程序需要用到的启动类，其中包括路由数组
            $this->app->bootstrapWith($this->bootstrappers());
        }
    }

    /**
     * Get the bootstrap classes for the application.
     *
     * @return array
     */
    protected function bootstrappers()
    {
        // 返回应用启动需要的类的命名空间的数组
        return $this->bootstrappers;
    }

    /**
     * The bootstrap classes for the application.
     *
     * @var array
     */
    protected $bootstrappers = [
        'Illuminate\Foundation\Bootstrap\DetectEnvironment',
        'Illuminate\Foundation\Bootstrap\LoadConfiguration',
        'Illuminate\Foundation\Bootstrap\ConfigureLogging',
        'Illuminate\Foundation\Bootstrap\HandleExceptions',
        'Illuminate\Foundation\Bootstrap\RegisterFacades',
        'Illuminate\Foundation\Bootstrap\RegisterProviders',
        'Illuminate\Foundation\Bootstrap\BootProviders',    // 启动应用，加载鉴权、路由等服务提供者
    ];

    /**
     * Get the route dispatcher callback.
     *
     * @return \Closure
     */
    protected function dispatchToRouter()
    {
        return function ($request) {
            $this->app->instance('request', $request);

            return $this->router->dispatch($request);
        };
    }
```

`Illuminate\Routing\Router`

```php
    /**
     * Dispatch the request to the application.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function dispatch(Request $request)
    {
        $this->currentRequest = $request;
        // 分发请求给路由并返回结果
        $response = $this->dispatchToRoute($request);

        return $this->prepareResponse($request, $response);
    }

    /**
     * Dispatch the request to a route and return the response.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return mixed
     */
    public function dispatchToRoute(Request $request)
    {
        // First we will find a route that matches this request. We will also set the
        // route resolver on the request so middlewares assigned to the route will
        // receive access to this route instance for checking of the parameters.
        // 获取处理请求的路由
        $route = $this->findRoute($request);
        // 设置Request->routeResolver属性，路由处理的回调
        $request->setRouteResolver(function () use ($route) {
            return $route;
        });
        // 启动RouteMatched上的监听事件，在FoundationServiceProvider中绑定了与表单请求有关的事件
        $this->events->fire(new Events\RouteMatched($route, $request));
        // 处理请求
        $response = $this->runRouteWithinStack($route, $request);

        return $this->prepareResponse($request, $response);
    }

    /**
     * Find the route matching a given request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Routing\Route
     */
    protected function findRoute($request)
    {
        // 匹配查找路由
        $this->current = $route = $this->routes->match($request);
        // 将路由绑定到容器的Illuminate\Routing\Route变量中
        $this->container->instance('Illuminate\Routing\Route', $route);
        // 替换路由器上的参数绑定，包括调用一些参数绑定的回调、处理模型绑定等
        return $this->substituteBindings($route);
    }

    /**
     * Find the first route matching a given request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Routing\Route
     *
     * @throws \Symfony\Component\HttpKernel\Exception\NotFoundHttpException
     */
    public function match(Request $request)
    {
        // 获取请求方式（GET/POST等），再获取该方式下绑定的所有路由
        $routes = $this->get($request->getMethod());

        // First, we will see if we can find a matching route for this current request
        // method. If we can, great, we can just return it so that it can be called
        // by the consumer. Otherwise we will check for routes with another verb.
        // 从所有路由中匹配到要请求的
        $route = $this->check($routes, $request);

        if (! is_null($route)) {
            // 匹配得到路由，则绑定：编译路由、绑定参数等操作
            return $route->bind($request);
        }

        // If no route was found we will now check if a matching route is specified by
        // another HTTP verb. If it is we will need to throw a MethodNotAllowed and
        // inform the user agent of which HTTP verb it should use for this route.
        // 从其他请求方式的路由中查找是否有能匹配的
        $others = $this->checkForAlternateVerbs($request);

        if (count($others) > 0) {
            return $this->getRouteForMethods($request, $others);
        }

        throw new NotFoundHttpException;
    }

    /**
     * Run the given route within a Stack "onion" instance.
     *
     * @param  \Illuminate\Routing\Route  $route
     * @param  \Illuminate\Http\Request  $request
     * @return mixed
     */
    protected function runRouteWithinStack(Route $route, Request $request)
    {
        // 中间件处理
        $shouldSkipMiddleware = $this->container->bound('middleware.disable') &&
                                $this->container->make('middleware.disable') === true;

        $middleware = $shouldSkipMiddleware ? [] : $this->gatherRouteMiddlewares($route);

        return (new Pipeline($this->container))
                        ->send($request)
                        ->through($middleware)
                        ->then(function ($request) use ($route) {
                            return $this->prepareResponse(
                                $request,
                                $route->run($request)
                            );
                        });
    }
```

`Illuminate\Routing\Route`

```php
    /**
     * Bind the route to a given request for execution.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return $this
     */
    public function bind(Request $request)
    {
        $this->compileRoute();

        $this->bindParameters($request);

        return $this;
    }

    /**
     * Compile the route into a Symfony CompiledRoute instance.
     *
     * @return void
     */
    protected function compileRoute()
    {
        $optionals = $this->extractOptionalParameters();

        $uri = preg_replace('/\{(\w+?)\?\}/', '{$1}', $this->uri);

        $this->compiled = (
            new SymfonyRoute($uri, $optionals, $this->wheres, [], $this->domain() ?: '')
        )->compile();
    }

    /**
     * Extract the parameter list from the request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return array
     */
    public function bindParameters(Request $request)
    {
        // If the route has a regular expression for the host part of the URI, we will
        // compile that and get the parameter matches for this domain. We will then
        // merge them into this parameters array so that this array is completed.
        $params = $this->matchToKeys(

            array_slice($this->bindPathParameters($request), 1)

        );

        // If the route has a regular expression for the host part of the URI, we will
        // compile that and get the parameter matches for this domain. We will then
        // merge them into this parameters array so that this array is completed.
        if (! is_null($this->compiled->getHostRegex())) {
            $params = $this->bindHostParameters(
                $request, $params
            );
        }

        return $this->parameters = $this->replaceDefaults($params);
    }

    /**
     * Run the route action and return the response.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return mixed
     */
    public function run(Request $request)
    {
        $this->container = $this->container ?: new Container;

        try {
            if (! is_string($this->action['uses'])) {
                // 如果操作是不是一个字符串，即是一个回调，调用
                return $this->runCallable($request);
            }
            // 操作是一个字符串，controller@action，调用控制器方法
            return $this->runController($request);
        } catch (HttpResponseException $e) {
            return $e->getResponse();
        }
    }

    /**
     * Run the route action and return the response.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return mixed
     */
    protected function runCallable(Request $request)
    {
        $parameters = $this->resolveMethodDependencies(
            $this->parametersWithoutNulls(), new ReflectionFunction($this->action['uses'])
        );

        return call_user_func_array($this->action['uses'], $parameters);
    }

    /**
     * Run the route action and return the response.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return mixed
     *
     * @throws \Symfony\Component\HttpKernel\Exception\NotFoundHttpException
     */
    protected function runController(Request $request)
    {
        list($class, $method) = explode('@', $this->action['uses']);

        return (new ControllerDispatcher($this->router, $this->container))
                    ->dispatch($this, $request, $class, $method);
    }
```

Illuminate\Routing\ControllerDispatcher

```php
    /**
     * Dispatch a request to a given controller and method.
     *
     * @param  \Illuminate\Routing\Route  $route
     * @param  \Illuminate\Http\Request  $request
     * @param  string  $controller
     * @param  string  $method
     * @return mixed
     */
    public function dispatch(Route $route, Request $request, $controller, $method)
    {
        $instance = $this->makeController($controller);

        return $this->callWithinStack($instance, $route, $request, $method);
    }

    /**
     * Make a controller instance via the IoC container.
     *
     * @param  string  $controller
     * @return mixed
     */
    protected function makeController($controller)
    {
        Controller::setRouter($this->router);

        return $this->container->make($controller);
    }

    /**
     * Call the given controller instance method.
     *
     * @param  \Illuminate\Routing\Controller  $instance
     * @param  \Illuminate\Routing\Route  $route
     * @param  \Illuminate\Http\Request  $request
     * @param  string  $method
     * @return mixed
     */
    protected function callWithinStack($instance, $route, $request, $method)
    {
        $shouldSkipMiddleware = $this->container->bound('middleware.disable') &&
                                $this->container->make('middleware.disable') === true;

        $middleware = $shouldSkipMiddleware ? [] : $this->getMiddleware($instance, $method);

        // Here we will make a stack onion instance to execute this request in, which gives
        // us the ability to define middlewares on controllers. We will return the given
        // response back out so that "after" filters can be run after the middlewares.
        return (new Pipeline($this->container))
                    ->send($request)
                    ->through($middleware)
                    ->then(function ($request) use ($instance, $route, $method) {
                        return $this->router->prepareResponse(
                            $request, $this->call($instance, $route, $method)
                        );
                    });
    }

    /**
     * Call the given controller instance method.
     *
     * @param  \Illuminate\Routing\Controller  $instance
     * @param  \Illuminate\Routing\Route  $route
     * @param  string  $method
     * @return mixed
     */
    protected function call($instance, $route, $method)
    {
        $parameters = $this->resolveClassMethodDependencies(
            $route->parametersWithoutNulls(), $instance, $method
        );

        return $instance->callAction($method, $parameters);
    }
```





