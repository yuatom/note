# 用户认证
##路由
`app/Http/routes.php`中配置：

```php
// 认证路由...
Route::get('auth/login', 'Auth\AuthController@getLogin');
Route::post('auth/login', 'Auth\AuthController@postLogin');
Route::get('auth/logout', 'Auth\AuthController@getLogout');
// 注册路由...
Route::get('auth/register', 'Auth\AuthController@getRegister');
Route::post('auth/register', 'Auth\AuthController@postRegister');
```

或：

```php
Route:auth();
```

`auth`方法如下：

```php
    public function auth()
    {
        // Authentication Routes...
        $this->get('login', 'Auth\AuthController@showLoginForm');
        $this->post('login', 'Auth\AuthController@login');
        $this->get('logout', 'Auth\AuthController@logout');

        // Registration Routes...
        $this->get('register', 'Auth\AuthController@showRegistrationForm');
        $this->post('register', 'Auth\AuthController@register');

        // Password Reset Routes...
        $this->get('password/reset/{token?}', 'Auth\PasswordController@showResetForm');
        $this->post('password/email', 'Auth\PasswordController@sendResetLinkEmail');
        $this->post('password/reset', 'Auth\PasswordController@reset');
    }
```

##跳转及验证规则
认证后跳转连接，`AuthController`中设置`redirectPath`（v5.1）或`redirectTo`（v5.2）属性。
`AuthController`的`validator`方法配置新用户注册的验证规则。
`AuthController`的`create`方法在用户表中创建记录。

```php
    protected function validator(array $data)
    {
        return Validator::make($data, [
            'name' => 'required|max:255',
            'email' => 'required|email|max:255|unique:users',
            'password' => 'required|confirmed|min:6',
        ]);
    }

    protected function create(array $data)
    {
        return User::create([
            'name' => $data['name'],
            'email' => $data['email'],
            'password' => bcrypt($data['password']),
        ]);
    }
```

##认证用户

判断是否通过认证，`check`方法

```php
// 使用check方法
if (Auth::check()) {
    // The user is logged in...
}
```
以上的`check`实际上是引用`Illuminate\Auth\GuardHelpers` trait的中方法。
>* Auth::check()调用到AuthManager的__call()方法；
>* AuthManager->__call()中通过call_user_func_array函数调用$this->guard()方法；
>* Illuminate\Auth\AuthManager->resolve()；
>* Illuminate\Auth\AuthManager->createTokenGuardDriver()/createSessionGuardDriver()，这两个方法返回TokenGuard/SessionGuard的实例，这两个实例中引用GuardHelpers；
>* 返回的TokenGuard/SessionGuard实例执行->guest()方法，该方法从GuardHelpers引用的；
>* GuardHelpers->guest()中在引用check()方法。
通过`Auth`门面访问认证用户：

```php
$user = Auth::user();
```

通过验证后，可以通过`Illuminate\Http\Request`实例访问用户

```php
if ($request->user()) {
	// $request->user() 返回认证用户实例...
}
```

##路由保护，即在路由中添加验证

通过添加中间件的方式对路由进行验证，`app\Http\Middleware\Authenticate.php`中间件来验证，该中间件在`Kernel.php`中注册：

```php
protected $routeMiddleware = [
        'auth' => \App\Http\Middleware\Authenticate::class,
        'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
        'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
        'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
    ];
```

使用：

```php
// 在routes.php中配置
// 使用路由闭包...
Route::get('profile', ['middleware' => 'auth', function() {
    // 只有认证用户可以进入...
}]);
// 使用控制器...
Route::get('profile', [
    'middleware' => 'auth',
    'uses' => 'ProfileController@show'
]);

// 在特定的控制中指定，在其构造方法通过middleware方法引入
public function __construct(){
    $this->middleware('auth');
}
```
控制器调用绑定中间件
>* App\Http\Middleware\Authenticate->handle()；
>* Auth::guard($guard)；
>* Illuminate\Auth\AuthManager->guard()；
>* Illuminate\Auth\AuthManager->resolve()；
>* Illuminate\Auth\AuthManager->createTokenGuardDriver()/createSessionGuardDriver()，这两个方法返回TokenGuard/SessionGuard的实例，这两个实例中引用GuardHelpers；
>* 返回的TokenGuard/SessionGuard实例执行->guest()方法，该方法从GuardHelpers引用的；
>* GuardHelpers->guest()中在引用check()方法。

##手动认证用户

通过`Auth`门面的`attempt`方法来手动认证：

```php
if (Auth::attempt(['email' => $email, 'password' => $password])) {
  // 认证通过...
  return redirect()->intended('dashboard');
}
```
该方法接收键值数组作为第一个参数，然后通过数组中的值去数据库中查找用户。上面的代码会去库中通过`email`的值获取用户，如果查找到用户，经哈希运算后存储在数据中的密码将会和传递过来的经哈希运算处理的密码值进行比较。如果两个经哈希运算的密码相匹配那么将会为这个用户开启一个认证Session。
重定向器上的 intended 方法将用户重定向到登录之前用户想要访问的 URL，在目标 URL 无效的情况下备用 URI 将会传递给该方法。
可以在参数数组中指定其他数据库字段的值来筛选用户：

```php
// 验证被标记为有效的用户
if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {
// The user is active, not suspended, and exists.
}
```

###其他认证方法
####模型实例
Auth的login方法，传入用户模型实例，传入实例必须是`Illuminate\Contracts\Auth\Authenticatable`的实现，Laravel 自带的`App\User`模型已经实现了该接口：

```php
Auth::login($user);
```

####用户id
传入认证用户的主键id

```php
Auth::loginUsingId(1);
```

####一次性认证用户
使用`once`方法只在单个请求中将用户登录到应用，而不存储任何 Session 和 Cookie。在构建无状态的api时可以用到。该方法用法和`attempt`差不多。

```php
if (Auth::once($credentials)) {
    //
}
```

// todo
访问指定 Guard 实例
你可以使用 Auth 门面的 guard 方法指定想要使用的 guard 实例，这种机制允许你在同一个应用中对不同的认证模型或用户表实现完全独立的用户认证。

##记住用户

传递一个布尔值给`attempt`第二个参数，使用这个之前需要在用户表中增加`remember_token`字段。

```php
// 验证
if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {
    // The user is being remembered...
}

// 判断用户是否使用“记住我”cookie进行认证
if (Auth::viaRemember()) {
    //
}
```

##社会化登录认证
Laravel 中还可以使用 `Laravel Socialite` 通过 OAuth 提供者进行简单、方便的认证，也就是社会化登录，目前支持使用Facebook、Twitter、LinkedIn、GitHub和Bitbucket进行登录认证。

###配置
在 `composer.json` 文件中添加依赖：

```shell
composer require laravel/socialite
```

在配置文件 `config/app.php` 中注册 `Laravel\Socialite\SocialiteServiceProvider`：

```php
'providers' => [
    // 其它服务提供者...
    Laravel\Socialite\SocialiteServiceProvider::class,
],
```

添加门面，`app.php`中的`aliases`数组中：

```php
'Socialite' => Laravel\Socialite\Facades\Socialite::class,
```

添加OAuth服务的信息，位于`config/services.php`文件中，例如github的，首先要在github创建应用得到应用的id及密钥等，然后添加到配置文件中：

```php
'github' => [
    'client_id' => 'your-github-app-id',
    'client_secret' => 'your-github-app-secret',
    'redirect' => 'http://your-callback-url',
],
```

###使用
配置路由：

```php
Route::get('auth/github', 'Auth\AuthController@redirectToProvider');
 Route::get('auth/github/callback', 'Auth\AuthController@handleProviderCallback');
```

添加控制器方法

```php
    /**
     * 将用户重定向到GitHub认证页面.
     *
     * @return Response
     */
    public function redirectToProvider()
    {
        return Socialite::driver('github')->redirect();
    }

    /**
     * 从GitHub获取用户信息.
     *
     * @return Response
     */
    public function handleProviderCallback()
    {
			$user = Socialite::driver('github')->user();
			// OAuth Two Providers
			$token = $user->token;
			// OAuth One Providers
			$token = $user->token;
			$tokenSecret = $user->tokenSecret;
			// All Providers
			$user->getId();
			$user->getNickname();
			$user->getName();
			$user->getEmail();
			$user->getAvatar();
    }
```
`redirect`方法将用户信息发送到OAuth 提供者，`user` 方法读取请求信息并从提供者中获取用户信息。

##自定义用户服务提供者
如果使用自定义用户数据库存储用户信息，则需要使用自己自定义的用户服务提供者来扩展。
在`Auth`门面的具体类中使用`provider`方法来自定义提供者的类。

```php
<?php

namespace App\Providers;

use Auth;
use App\Extensions\RiakUserProvider;
use Illuminate\Support\ServiceProvider;

class AuthServiceProvider extends ServiceProvider{
    /**
     * Perform post-registration booting of services.
     *
     * @return void
     */
    public function boot()
    {
        Auth::provider('riak', function($app,array $config) {
            // 返回Illuminate\Contracts\Auth\UserProvider实例...
            return new RiakUserProvider($app['riak.connection']);
        });
    }

    /**
     * 在容器中注册绑定.
     *
     * @return void
     */
    public function register()
    {
        //
    }
}
```

注册用户提供者后，还需要在配置文件中切换到新的用户提供者，在`config/auth.php`的`providers`数组中配置：

```php
'providers' => [
    'users' => [
        'driver' => 'riak',
    ],
],
```

配置后在`guards`中使用

```php
'guards' => [
    'web' => [
        'driver' => 'session',
        'provider' => 'users',
    ],
],
```

###相关契约
####UserProvider 契约

Illuminate\Contracts\Auth\UserProvider 实现只负责从持久化存储系统中获取Illuminate\Contracts\Auth\Authenticatable 实现，例如MySQL、Riak等等。这两个接口允许 Laravel 认证机制继续起作用而不管用户数据如何存储或者何种类来展现。

让我们先看看 Illuminate\Contracts\Auth\UserProvider契约：

```php
<?php

namespace Illuminate\Contracts\Auth;

interface UserProvider {

    public function retrieveById($identifier);
    public function retrieveByToken($identifier, $token);
    public function updateRememberToken(Authenticatable $user, $token);
    public function retrieveByCredentials(array $credentials);
    public function validateCredentials(Authenticatable $user, array $credentials);

}
```
`retrieveById` 方法通常获取一个代表用户的键，例如 MySQL 数据中的自增ID。该方法获取并返回匹配该ID的`Authenticatabl` 实现。

`retrieveByToken` 函数通过唯一标识和存储在 `remember_toke`n 字段中的“记住我”令牌获取用户。和上一个方法一样，该方法也返回 `Authenticatabl` 实现。

`updateRememberToken` 方法使用新的 `$token` 更新 `$user` 的 `remember_token` 字段，新令牌可以是新生成的令牌（在登录是选择“记住我”被成功赋值）或者null（用户退出）。

`retrieveByCredentials` 方法在尝试登录系统时获取传递给 `Auth::attempt` 方法的认证信息数组。该方法接下来去底层持久化存储系统查询与认证信息匹配的用户，通常，该方法运行一个带“where”条件（`$credentials[‘username’]`）的查询。然后该方法返回 `UserInterface` 的实现。这个方法不做任何密码校验和认证。

`validateCredentials` 方法比较给定 `$user和$credentials` 来认证用户。例如，这个方法比较 `$user->getAuthPassword()` 字符串和经 `Hash::make` 处理的 `$credentials['password']`。这个方法只验证用户认证信息并返回布尔值。

####Authenticatable 契约

既然我们已经探索了 UserProvider 上的每一个方法，接下来让我们看看 Authenticatable。该提供者应该从 retrieveById 和 retrieveByCredentials 方法中返回接口实现：

```php
<?php

namespace Illuminate\Contracts\Auth;

interface Authenticatable {

    public function getAuthIdentifier();
    public function getAuthPassword();
    public function getRememberToken();
    public function setRememberToken($value);
    public function getRememberTokenName();

}
```
这个接口很简单，getAuthIdentifier 方法返回用户“主键”，在 MySQL 后台中是ID，getAuthPassword 返回经哈希处理的用户密码，这个接口允许认证系统处理任何用户类，不管是你使用的是 ORM 还是存储抽象层。默认情况下，Laravel 自带的 app 目录下的 User 类实现了这个接口，所以你可以将这个类作为实现例子。

