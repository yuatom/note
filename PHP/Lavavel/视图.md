# 视图
##基本
在resources/views目录下定义greeting.php：

```html
<!-- 该视图存放 resources/views/greeting.php -->

<html>
    <body>
        <h1>Hello, <?php echo $name; ?></h1>
    </body>
</html>
```
在程序中调用全局辅助函数`view`来显示，第一个参数是视图文件名，第二个参数是数据数组。视图文件目录支持嵌套，使用”.“来嵌套视图文件

```php
// resources/views/greeting.php
Route::get('/', function () {
    return view('greeting', ['name' => 'James']);
});

// 嵌套调用视图，resources/views/admin/profile.php
Route::get('/', function () {
	return view('admin.profile', $data);
});

// 判断视图是否存在
if (view()->exists('emails.customer')) {
    //
}
```

##视图数据

```php
// 添加独立的视图数据（而不是一个数组
$view = view('greeting')->with('name', 'Victoria');
```
> 共享视图数据
有时候我们需要在所有视图之间共享数据片段，这时候可以使用视图工厂的 share 方法，通常，需要在服务提供者的 boot 方法中调用 share 方法，你可以将其添加到 AppServiceProvider 或生成独立的服务提供者来存放它们

```php
<?php

namespace App\Providers;

class AppServiceProvider extends ServiceProvider
{
    /**
     * 启动所有应用服务
     *
     * @return void
     */
    public function boot()
    {
        view()->share('key', 'value');
    }

    /**
     * 注册服务提供者
     *
     * @return void
     */
    public function register()
    {
        //
    }
}
```

##视图Composer
当视图被渲染时的回调或者类方法。
如果有一些数据要在每次视图渲染时都做绑定，可以使用视图Composer**将逻辑组织到一个单独的地方**。
视图Composer需要：
>*在服务提供者中view()->composer()绑定；
>*Composer类，实现composer方法，该方法会在视图渲染是执行

###使用
>* 1在服务提供者中注册视图Composer，使用辅助函数 view 来访问 Illuminate\Contracts\View\Factory 的底层实现。Laravel 不会包含默认的视图 Composer 目录，可以自己创建一个 App\Http\ViewComposers 目录

```php
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class ComposerServiceProvider extends ServiceProvider
{
    /**
     * 在容器中注册绑定.
     *
     * @return void
     * @author http://laravelacademy.org
     */
    public function boot()
    {
        // 使用基于类的composers...
        view()->composer(
            'profile', 'App\Http\ViewComposers\ProfileComposer'
        );

        // 使用基于闭包的composers...
        view()->composer('dashboard', function ($view) {
        });
    }

    /**
     * 注册服务提供者.
     *
     * @return void
     */
    public function register()
    {
        //
    }
}
```

>* 2在app.php中的providers数组中添加服务提供者。
>* 3上面注册了Composer，每次profile视图被渲染时，都会调用ProfileComposer@compose。视图被渲染前，Composer 类的 compose 方法被调用，同时 Illuminate\Contracts\View\View 被注入该方法，从而可以使用其 with 方法来绑定数据到视图。下面是这个profile的Composer类

```php
<?php

namespace App\Http\ViewComposers;

use Illuminate\Contracts\View\View;
use Illuminate\Users\Repository as UserRepository;

class ProfileComposer
{
    /**
     * 用户仓库实现.
     *
     * @var UserRepository
     */
    protected $users;

    /**
     * 创建一个新的属性composer.
     *
     * @param UserRepository $users
     * @return void
     */
    public function __construct(UserRepository $users)
    {
        // Dependencies automatically resolved by service container...
        $this->users = $users;
    }

    /**
     * 绑定数据到视图.
     *
     * @param View $view
     * @return void
     */
    public function compose(View $view)
    {
        $view->with('count', $this->users->count());
    }
}
```
###添加Composer到多个视图

```php
view()->composer(
    ['profile', 'dashboard'],
    'App\Http\ViewComposers\MyViewComposer'
);

// 到所有视图
view()->composer('*', function ($view) {
    //
});
```

##视图创建器
视图创建器和视图 Composer 非常类似，不同之处在于前者在视图实例化之后立即失效而不是等到视图即将渲染。使用 create 方法即可注册一个视图创建器：

```php
view()->creator('profile', 'App\Http\ViewCreators\ProfileCreator');
```


